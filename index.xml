<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello world!</title>
    <link>https://shiweiHou.github.io/</link>
    <description>Recent content on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 06 Oct 2016 21:16:05 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LintCode 连续子数组求和</title>
      <link>https://shiweihou.github.io/lintcode/20161006-4/</link>
      <pubDate>Thu, 06 Oct 2016 21:16:05 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-4/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大。输出答案时，请分别返回第一个数字和最后一个数字的下标。（如果两个相同的答案，请返回其中任意一个）&lt;/p&gt;

&lt;p&gt;样例：
给定&lt;code&gt;[-3, 1, 3, -3, 4]&lt;/code&gt;,返回&lt;code&gt;[1, 4]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;最大连续子数组问题，只要在求最大连续子数组和的过程中，记录最大值更改时的下标start和end就可以。利用动态规划来求最大子数组，因为要求是连续的，设dp[i]为第i个位置子数组的最大值。第i个位置的数要不要放进去，就要看如果第i个位置放进去，与dp[i-1]的和是否大于A[i],如果大于，就放进去，否则不放。时间复杂度O(n),代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; continuousSubarraySum(vector&amp;lt;int&amp;gt;&amp;amp; A) {
    // Write your code here
    vector&amp;lt;int&amp;gt; ret;
    if (A.empty()) return ret;
    int n = A.size();
    vector&amp;lt;int&amp;gt; cur(n,0);
    int maxSum = A[0];
    cur[0] = A[0];
    int curStart = 0;
    int start = 0;
    int end = 0;
    for (int i = 1; i &amp;lt; n; ++i) {
        if (cur[i-1] + A[i] &amp;gt; A[i]) { // 放进去，curs s e均不作更改
            cur[i] = cur[i-1] + A[i];
        } else {
            cur[i] = A[i];
            curStart = i;
        }
        if (cur[i] &amp;gt; maxSum) {
            maxSum = cur[i];
            start = curStart;
            end   = i;
        }
    }

    ret.push_back(start);
    ret.push_back(end);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 排序矩阵中的从小到大第k个数</title>
      <link>https://shiweihou.github.io/lintcode/20161006-3/</link>
      <pubDate>Thu, 06 Oct 2016 21:08:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-3/</guid>
      <description>&lt;p&gt;题目要求：&lt;/p&gt;

&lt;p&gt;在一个排序矩阵中找从小到大的第 k 个整数。排序矩阵的定义为：每一行递增，每一列也递增。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定 K = 4 和一个排序矩阵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
 [1,5,7],
 [3,7,8],
 [4,8,9],
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回答案 5&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始想错了，以为第i行的数字一定比第i+1行的数字要小，其实题目只要求每一行是递增，每一列数字是递增的，但并没有要求第i行的最后一个数字一定比第i+1行的倒数第二个数字小。我一开始是这样认为的，然后写好提交，发现居然过了73%的test，好神奇~~&lt;/p&gt;

&lt;p&gt;后来发现需要利用堆来做，利用STL里的堆模板，很容易写出来，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int k) {
    // write your code here
    int row = matrix.size();
    if (row == 0 || k == 0) return 0;
    int col = matrix[0].size();

    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;gt;&amp;gt; dui; //构建最小堆
    map&amp;lt;pair&amp;lt;int, int&amp;gt;, bool&amp;gt; visited;

    dui.push(make_pair(matrix[0][0], make_pair(0,0)));
    visited[make_pair(0,0)] = true;

    while (k--) {
        pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt; cur = dui.top();
        dui.pop();

        if (k == 0) return cur.first;

        int x = cur.second.first + 1; // down
        int y = cur.second.second;
        if (x &amp;lt; row &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
        --x;
        ++y;//right-&amp;gt;

        if (y &amp;lt; col &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 硬币排成线||</title>
      <link>https://shiweihou.github.io/lintcode/20161006-2/</link>
      <pubDate>Thu, 06 Oct 2016 20:46:56 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-2/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值高的人获胜。&lt;/p&gt;

&lt;p&gt;请判定 第一个玩家 是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定数组 A = [1,2,2],返回true&lt;/li&gt;
&lt;li&gt;给定数组 A = [1,2,4],返回false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;这道题看上去和前面那道硬币排线题很像，只不过第一个玩家赢的条件从是否能拿到最后一枚硬币变成第一个玩家拿到的硬币价值总和是否大于第二个玩家拿到的硬币价值总和。典型的博弈论题目，每个人都尽量在保证自己获得最大价值的情况下让对方获得最小价值。设第一个玩家为player1，第二个玩家为player2，v[i]为player1从硬币i到end所能拿到的最大价值。我们从后往前推：
对于硬币i和硬币i+1，player1有两种情况可以选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拿走硬币i，获得的价值为values[i]: 在player1拿走硬币i的情况下，那么player2有两种可以选择，一是拿走硬币i+1，那么此时player1拿走硬币i获得的价值就为 v1 = values[i] + v[i+2];二是拿走硬币i和硬币i+1,那么此时player1拿走硬币i获得的价值为 v2 = values[i] + v[i+3]。当然在博弈原则下，player2肯定是想让player1获得的价值最小，所以player1在拿走硬币i获得的最大价值为 choose1 = values[i] + min(v[i+2], v[i+3]).&lt;/li&gt;
&lt;li&gt;拿走硬币i和硬币i+1，获得的价值为values[i+1] + values[i]: 同上所述，player2同样有两种选择，一是拿走硬币i+2和硬币i+3，此时player1所能获得的最大价值为 v3 = values[i] + values[i+1] + v[i+4];二是拿走硬币i+2，此时player1所能获得的最大价值为 v4 = values[i] + values[i+1] + v[i+3]。同样基于博弈，player2肯定想让player1获得的最大价值最小，所以player1在拿走硬币i和硬币i+1的情况下获得的最大价值为 choose2 = values[i] + values[i+1] + min(v[i+3], v[i+4]).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，player1在两种选择下，要选择一个最大的价值 v[i] = max(choose1, choose2).
代码如下，注意越界情况，所以我定义v的数组时多定义了两个，并且设置为0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool firstWillWin(vector&amp;lt;int&amp;gt; &amp;amp;values) {
    // write your code here
    if (values.empty()) return false;

    int len = values.size();
    if (len &amp;lt;= 2) return true;
    vector&amp;lt;int&amp;gt; v(len+2,0);
    v[len-1] = values[len-1];
    v[len-2] = values[len-1] + values[len-2];
    int sum = values[len-1] + values[len-2];
    for (int i = len - 3; i &amp;gt;= 0; --i) {
        sum += values[i];
        int choose1, choose2;
        choose1 = values[i] + min(v[i+2], v[i+3]);
        choose2 = values[i] + values[i+1] + min(v[i+4],v[i+3]);
        v[i] = max(choose1, choose2);
    }

    return sum-v[0] &amp;lt; v[0];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode-硬币排成线</title>
      <link>https://shiweihou.github.io/lintcode/20161006/</link>
      <pubDate>Thu, 06 Oct 2016 20:29:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有N个硬币排成一条线，两个参赛者轮流从右边依次拿走1个或2个硬币，直到没有硬币为止。拿到最后一个硬币的玩家获胜。请判定第一个玩家是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;n = 1, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 2, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 3, 返回 false&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 4, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 5, 返回 true
思路：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这道题是有关博弈论的初级题目。题目很简单，就是判断第一个人最后能否拿到最后一枚硬币。我们不能依赖于第二个玩家怎么拿，我们需要的答案是无论第二个玩家怎么拿，第一个玩家在现有的拿法下（每次拿一个或者两个）可以拿到最后一个硬币或者拿不到。很明显，当只剩下三个硬币的时候，无论第一个玩家怎么拿，最后一个硬币都有可能不是他的，也就是说第一个玩家没有机会获胜。因此，我们只需要判断当还剩下三个的时候，最后一个拿硬币的人是否是第一个人就可以了，很明显可以用递归来做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n) {
        // write your code here
        if (n &amp;lt;= 0 || n == 3) return false;
        else if (n &amp;lt;= 4) return true;
        return firstWillWin(n-3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理，亦可以利用动态规划来做，因为第i个硬币是否为第一个人拿和第i-3个硬币是否是第一个人拿真假值相同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        vector&amp;lt;bool&amp;gt; dp(n + 1, false);
        dp[0] = false;
        dp[1] = true;
        dp[2] = true;
        dp[3] = false;
        for (int i = 4; i &amp;lt;= n; ++i) {
            dp[i] = dp[i-3];
        }
        return dp[n];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种更为简洁的数学方法，因为我们发现如果硬币的个数不是3的倍数，那么第一个人就可以拿到最后一个硬币：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        if (n &amp;lt;= 0) return false;
        if (n % 3 == 1 || n % 3 == 2) return true;
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>全排列问题</title>
      <link>https://shiweihou.github.io/algorithm/%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 04 Oct 2016 20:34:33 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>

&lt;h2 id=&#34;全排列的非递归实现&#34;&gt;全排列的非递归实现：&lt;/h2&gt;

&lt;p&gt;考虑排列 “926520”这个字符串，它的下一个排列是哪一个呢？我们从后往前开始找，找到第一组相邻数字递增的组合：0-2-5-6 都不行，但 6-2可以，即 2 和 6 这组数字是从后往前数，第一组递增的。这时候，2 即为 替换数， 替换数的下标称之为替换点。找到替换点之后，从替换点开始，向后找到一个比替换点大的数里面最小的那个大数，即为 5，这时候，将 5 和2进行交换，得到956220，再将替换点之后的数进行反转，得到950226 ，这时候这个排列就是下一个排列。对于像54321这种已经是最后一个排列的全排列，其下一个排列当然为12345 。&lt;/p&gt;

&lt;p&gt;对于从替换点开始，找到后面最小的大数，我们可以从后往前找，因为除了替换点和替换点后面的数之外，其余的都是递减的（从前往后看），所以最右边的第一个大于替换数的数一定是最小的大数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void nextPermutation(vector&amp;lt;int&amp;gt; &amp;amp;nums) {

    if (nums.empty()) return ;
    int len = nums.size();
    int i = len - 1;
    bool flag = false;

    while (i &amp;gt; 0 ) { // 找替换点
        if (nums[i] &amp;lt;= nums[i - 1]) --i;
        else {
            flag = true;
            break;
        }
    }

    if (flag == false) reverse(nums.begin(), nums.end());
    else {
        --i;
        int j = i + 1;
        int pos = j;
        while (j &amp;lt; len) { // 找替换点之后最小的大数
            if (nums[j] &amp;gt; nums[i]) {
                if (nums[j] &amp;lt;= nums[pos]) pos = j;
            }
            ++j;
        }
        swap(nums[i], nums[pos]);
        ++i;
        j = len - 1;  
        while (i &amp;lt; j) swap(nums[i++], nums[j--]);  // 反转
    }

    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一种另类的全排列问题&#34;&gt;一种另类的全排列问题：&lt;/h2&gt;

&lt;p&gt;给你一个排列，问这是在所有的全排列中，第几个排列？排列序号从1开始，按顺序增长的方向开始。排列中不包含重复数字。例如给定排列124，它是第一个排列。看到这个题目首先想到的就是求出所有的全排列，然后在求解过程中与给出的排列进行比较，看看是第几个。思路是ok的，然而在oj上面会超时，说明这个方法不行。也就说其实不是要让你求出所有的排列然后进行比较，而是化成组合问题，在这个排列前，有多少个排列。&lt;/p&gt;

&lt;p&gt;例如对于排列  list = 95412：
在排列list前面的所有的全排列中，位于位置1的数字可能是5、4、1、2中的任意一个数，而一旦位置1确定了，其全排列个数为4！（5-1）个。
同理，对应位置2的数字可以是4、 1、 2的任意一个，而一旦位置2确定了，其全排列个数为3！（5-2）个。
同理，对应位置3的数字可以是1 、 2的任意一个，而一旦位置3确定了，其全排列个数为2！（5-3）个。
同理，对应位置4的数字可以是0个（因为没有数字比1还小），一旦位置4确定了，其全排列个数为1！（5-4）个。
最后，对应位置5的数字可以是0个，全排列个数为0！（5-5）个。
从上面我们就可以看出，对于一个给定的排列，求出其在全排列的的序号，只需要对给定的序列进行查找，找到从位置2开始一直到倒数第二个位置可变数字的个数（就是该位置后面的，比当前位置数字小的）*（n-i）!.
即，对于位置 i （i &amp;gt;= 0 &amp;amp;&amp;amp;  i&amp;lt; n-1）,其后面的数字比当前 i 位置小的个数为 k 个，则其排列个数为 k * (n - i - 1)! 个。对这个排列整个遍历一遍，就得到当前排列之前的全排列个数。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long long permutationIndex(vector&amp;lt;int&amp;gt;&amp;amp; A) {

    map&amp;lt;int, int&amp;gt; mapCount;
    for (int i = 0; i &amp;lt; A.size() - 1; ++i) {
        int count = 0;
        for (int j = i + 1; j &amp;lt; A.size(); ++j) {
            if (A[i] &amp;gt; A[j]) {
                ++count;
            }
        }
        // 保存i个位置后面有多少个比它小的
        mapCount[A[i]] = count;
    }

    long ans = 0;
    int n = A.size();
    for (int i = 0; i &amp;lt; A.size() - 1; ++i) {
        int k = n - i - 1;
        long fact = 1;
        // 当前位置的阶乘
        while (k &amp;gt; 0) {  
            fact *= k;
            --k;
        }
        // 阶乘 * k
        ans += mapCount[A[i]] * fact;
    }
    // 因为前面求到的是当前排列前总共有多少个全排列，所以自然当前排列是 ans + 1 个排列
    return ++ans;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一种另类的全排列问题-2&#34;&gt;一种另类的全排列问题 2：&lt;/h2&gt;

&lt;p&gt;类似于前面的问题，只不过是排列中有重复数字，求当前排列是第几个。基于前面的问题来做，假如没有重复数字，那么答案自然是上面那个。因为有重复数字，只要在发现重复数的那一位用 k * (n - i - 1)! 的结果除去重复的次数就行，当然重复的次数也要做阶乘，例如排列中有3个2,4个8，重复次数
为 3！ * 4 ！，代码如下：&lt;/p&gt;

&lt;p&gt;ps: 这段代码说实在没有太懂&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long long permutationIndexII(vector&amp;lt;int&amp;gt;&amp;amp; A) {
    // Write your code here

    long long index = 0, fact = 1, dup = 1;

    map&amp;lt;int, int&amp;gt; mapCount;
    for (int i = A.size()-1; i &amp;gt;= 0; i--) {

        if (mapCount.find(A[i]) == mapCount.end()) mapCount[A[i]] = 1;
        else {

            mapCount[A[i]] += 1;
            dup *= mapCount[A[i]];
        }
        int rank = 0;
        for (int j = i+1; j &amp;lt; A.size(); j++) {
            if (A[j] &amp;lt; A[i]) rank++;
        }
        index += rank * fact / dup;
        fact *= (A.size() - i);
    }
    return index+1;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>https://shiweihou.github.io/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 04 Oct 2016 19:27:50 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;p&gt;回文的意思大家应该都知道，就是一个子串，从前往后读与从后往前读是一模一样的。
最长回文子串的意思就是：在一个给定的字符串中，找到一个最长的回文子串。&lt;/p&gt;

&lt;p&gt;一开始的思路很复杂：例如对于串：&lt;strong&gt;abdcdedcab&lt;/strong&gt;，最长回文子串为 &lt;strong&gt;cdedc&lt;/strong&gt;，我一开始的想法是：对于母串，首先遍历一遍，建立一个&lt;strong&gt;map&lt;/strong&gt;，保存每个字符所在的位置。map类型为&lt;code&gt;map&amp;lt;char,stack&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;,例如对于字符a，它在母串中的位置是 0,8，那么map[a] = [0,8].保留下所有的字符后，因为子串要求是连续的，所以对于母串的每一个不同的字符都遍历一遍，然后在 stack 中找到它出现的另一个位置，例如还是a，它的位置有两个，0和8，那么就判断 0 - 8 之间是否为回文串。这样所有的遍历一遍，找到最长的那个。在Lintcode上，通过了73%的数据，因为我一开始的代码是 &lt;strong&gt;以母串的前面第一个为基准&lt;/strong&gt;，然后以该字符在其它位置出现作为比较，这样其实没法通过类似于 aaaabaaa的数据。我得到的结果为aaaa，而其实答案为aaabaaa。后来我就想了下，其实我只是对该字符在母串中的位置，两两组合，只判断了一部分情况，例如前面的aaaabaaa,对于a，我只判断了位置（0,7）（0，6）（0,5）（0,3）（0,2）（0,1）这几种情况，而没有判断（1,7）（1,6）（1，5）等等这些情况，所以是没办法通过所有测试数据的。后来就用上面的两两组合思想，后来发现和暴搜是一样的，时间复杂度是 O(n^3), TLE。&lt;/p&gt;

&lt;p&gt;后来想到，暴搜的思想是从外往里搜，找到每一个可能的子串，判断是不是回文。这个过程中其实有很多次重复的动作，那么能不能换个思路，从里往外搜。我们知道对于每一个字符，以它为基准，往外扩展，由于是回文，i-1和i+1位置的字符必然相等。通过以上的思想可以得到如下代码：（考虑　aba 和 abba 两种奇偶不同的情况）：时间复杂度为 O(n^2)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 * @param s input string
 * @return the longest palindromic substring
 */
string longestPalindrome(string&amp;amp; s) {
    // Write your code here
    if (s.empty()) return NULL;
    int len = s.size();
    int pos = 0;
    string ans = &amp;quot;&amp;quot;;

    while (pos &amp;lt; len) {
        string s1 = huiwen(s, pos, pos); // aba 的情况
        string s2 = huiwen(s, pos, pos + 1); // abba 的情况
        if (s1.size() &amp;gt; s2.size()) {
            ans = ans.size() &amp;gt; s1.size() ? ans : s1;
        }
        else {
            ans = ans.size() &amp;gt; s2.size() ? ans : s2;
        }
        ++pos;
    }

    return ans;
}

string huiwen(string &amp;amp;s, int ss, int ee) {

    if (ee &amp;gt;= s.size()) return s.substr(ss,1);

    while (ss &amp;gt;= 0  &amp;amp;&amp;amp; ee &amp;lt; s.size()) {
        if (s[ss] != s[ee]) {
            break;
        }
        --ss;
        ++ee;
    }

    if (ss == ee || ss + 1 == ee) return s.substr(ss, 1);
    else return s.substr(ss+1, ee - ss - 1);
}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面的算法思想，可以衍生出很多 O(N^2)的算法，例如动态规划。思想就是设置标志flag[N][N]，如果 s[i] == s[j] &amp;amp;&amp;amp; flag[i+1][j-1] == true，那么 flag[i][j] == true;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 * @param s input string
 * @return the longest palindromic substring
 */
string longestPalindrome(string&amp;amp; s) {
    // Write your code here

    if (s.empty()) return &amp;quot;&amp;quot;;
    int len = s.size();
    vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; flag (len, vector&amp;lt;bool&amp;gt;(len, false));

    for (int i = 0; i &amp;lt; len; ++i) {
        for (int j = 0; j &amp;lt; len; ++j) {
            // 当i==j的时候，单个字符明显为回文
            // 当i &amp;gt; j 的时候，设置为true是为了防止出现 s[i] == s[i+1]这种情况，反正如果不相等在下面又会变成false
            if (i &amp;gt;= j) flag[i][j] = true;
        }
    }

    int ss = 0;
    int maxLen = 1;

    for (int j = 1; j &amp;lt; len; ++j) {
        for (int i = 0; i &amp;lt; j; ++i) {
            if (s[i] == s[j]) {
                if (flag[i+1][j-1]) flag[i][j] = true;
                else flag[i][j] = false;

                if (flag[i][j]) {
                    if (maxLen &amp;lt; j - i + 1) {
                        ss = i;
                        maxLen = j - i + 1;
                    }
                }
            } else flag[i][j] = false;
        }
    }

    return s.substr(ss, maxLen);
    }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网上还有一种算法，Manacher算法，时间复杂度是 O(N)，有兴趣的同学可以去找下。&lt;/p&gt;

&lt;p&gt;另外，有的同学会说，如果把字符串 s 翻转过来，变成 s&amp;rsquo; ,那么求s和s&amp;rsquo;的最长公共连续子序列是不是就是就是答案？其实不是，例如对于串 &lt;strong&gt;abcdefgdcba&lt;/strong&gt;，如果翻转，就变成 &lt;strong&gt;abcdgfedcba&lt;/strong&gt;, 那么最长子序列为 &lt;strong&gt;abcd&lt;/strong&gt; ，但这个明显不是回文的，所以求两个串的最长公共连续子序列并不一定是回文的。当然，如果要求都是不连续的，那么当然可以这样求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>first</title>
      <link>https://shiweihou.github.io/lintcode/first/</link>
      <pubDate>Mon, 03 Oct 2016 20:08:35 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/first/</guid>
      <description>&lt;p&gt;lintcode&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; explicit关键字</title>
      <link>https://shiweihou.github.io/cplusplus/C&#43;&#43;%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sat, 17 Sep 2016 15:08:13 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/C&#43;&#43;%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;p&gt;&lt;strong&gt;被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎，因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++ explicit关键字用于修饰类的构造函数，用于显示的表明类的构造函数是显示的，禁止编译器执行非预期的（大部分都是隐式的，不受期待的）类型转换。
例如对于一个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
public:
     A(int num);//默认构造函数
     int _num;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A a1(3);
A a1 = 3;//编译器会将整型的 3 转换为 类A 的形式，类似于 A temp(3); A a1 = temp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个操作
这两种方式都是正确的，都是定义了一个类对象并默认初始化num为3.但是有个问题，对于第二种定义方式，我们原意可能并不是想将3作为类的初始值，而是
对类内的某个属性进行初始化（更一般来讲，我们看到 A a1 = 3 这种形式的代码的时候，会下意识的认为A是一个类型而不是一个类）这样，就会产生一个显示的错误：对一个类进行赋值而不是对一个类型进行赋值。&lt;/p&gt;

&lt;p&gt;要避免这种情况就需要在类的构造函数前键入explicit关键字，用于告诉编译器，禁止&lt;strong&gt;隐性的类型转换。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A{
public:
     explicit A(int num);//默认构造函数
     int _num;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A a1 = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会提示错误了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基类派生类的一些问题</title>
      <link>https://shiweihou.github.io/cplusplus/%E5%9F%BA%E7%B1%BB%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 17 Sep 2016 15:08:13 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/%E5%9F%BA%E7%B1%BB%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%97%AE%E9%A2%98/</guid>
      <description>

&lt;h2 id=&#34;基类成员在派生类的访问属性&#34;&gt;基类成员在派生类的访问属性：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* 基类的私有成员无论是什么继承方式，在派生类中均不可以直接访问
* 在公有继承下，基类的保护成员和公有成员均保持原访问属性
* 在保护继承方式下，基类的保护和公有成员在派生类的访问属性中均为保护属性
* 在私有继承方式下，基类的保护和公有成员在派生类的方位属性中均未私有属性
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;虚函数-多态&#34;&gt;虚函数，多态：&lt;/h2&gt;

&lt;p&gt;基类指针可以用派生类对象赋值，但如果基类和派生类的成员函数都是普通函数，那么虽然基类指针指向派生类的对象，但&lt;strong&gt;基类指针仍然使用基类的成员函数，而不是使用派生类对象的成员函数。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;

class People{
protected:
   char *name;
public:
   People(char *name) :name(name){};
   // virtual void display() {cout &amp;lt;&amp;lt; &amp;quot;people: &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } , 构成多态
   void display(){ cout &amp;lt;&amp;lt; &amp;quot;people: &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; }
};

class Student :public People{
public:
   Student(char *name) :People(name){};
   void display(){ cout &amp;lt;&amp;lt; &amp;quot;Student: &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; }
};

int main(){
   People *p = new People(&amp;quot;teacher&amp;quot;);
   p-&amp;gt;display();

   p = new Student(&amp;quot;student&amp;quot;);
   p-&amp;gt;display();

   return 0；
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序的输出为，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;people:teacher
people:student
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，基类指针虽然指向了派生类对象，但其使用的仍是基类的成员函数。&lt;/p&gt;

&lt;p&gt;解决这个问题的方法，就是在成员函数声明为&lt;strong&gt;虚函数&lt;/strong&gt;。只需在基类成员函数前加上 virtual 关键字，程序的输出就可以变为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;people:teacher
student:student
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;借助虚函数，基类指针既可以使用基类的成员函数，也可以使用派生类的成员函数，它有多种形态，或多种表现方式，这就是多态&lt;strong&gt;（polymorphism）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在上面的代码中，当p指向不同的对象时，它所执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。
C++提供多态的目的是：&lt;strong&gt;可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;构成多态的条件&#34;&gt;构成多态的条件：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;必须存在继承关系&lt;/li&gt;
&lt;li&gt;继承关系中必须有同名的虚函数，并且它们是覆盖关系，不能是隐藏&lt;/li&gt;
&lt;li&gt;存在基类的指针，通过该指针调用虚函数&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class Base{
public:
    void a(){ cout&amp;lt;&amp;lt;&amp;quot;Base::a()&amp;quot;&amp;lt;&amp;lt;endl; }
    virtual void b(){ cout&amp;lt;&amp;lt;&amp;quot;Base::b()&amp;quot;&amp;lt;&amp;lt;endl; }
    virtual void c(){ cout&amp;lt;&amp;lt;&amp;quot;Base::c()&amp;quot;&amp;lt;&amp;lt;endl; }
};
class Derived: public Base{
public:
    //覆盖基类普通成员函数，不构成多态
    void a(){ cout&amp;lt;&amp;lt;&amp;quot;Derived::a()&amp;quot;&amp;lt;&amp;lt;endl; }
    //覆盖基类虚函数，构成多态
    virtual void b(){ cout&amp;lt;&amp;lt;&amp;quot;Derived::b()&amp;quot;&amp;lt;&amp;lt;endl; }
    //隐藏基类虚函数，不构成多态
    virtual void c(int n){ cout&amp;lt;&amp;lt;&amp;quot;Derived::c()&amp;quot;&amp;lt;&amp;lt;endl; }
    //派生类新增函数
    int d(){ cout&amp;lt;&amp;lt;&amp;quot;Derived::d()&amp;quot;&amp;lt;&amp;lt;endl; }
};
int main(){
    Base *p = new Derived;
    p -&amp;gt; a();
    p -&amp;gt; b();
    p -&amp;gt; c(0);  //Compile Error
    p -&amp;gt; d();  //Compile Error
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;文件的I/O</title>
      <link>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 03 Jun 2016 10:08:13 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>

&lt;p&gt;C++关于文件的读写，通常来讲，我们最常用的就是对txt文件的读写操作，有时候我们需要打开一个已存在的txt文件进行读取，或者需要将一些数据写入到txt文件中。&lt;/p&gt;

&lt;h2 id=&#34;读取文件操作所需的头文件&#34;&gt;读取文件操作所需的头文件&lt;/h2&gt;

&lt;p&gt;C++中有一个头文件 &lt;fstream&gt;,包含3个基本的类成员：ifstream, ofstream, fstream。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* ifstream：定义读取的文件，进行读操作，而无法进行写操作
* ofstream：定义要写的文件，进行写操作，而无法进行读操作
* fstream：定义读写文件，既可以进行读操作，也可以进行写操作
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ifsteam&#34;&gt;ifsteam&lt;/h2&gt;

&lt;p&gt;假如a.txt的格式类似于这样
&amp;ldquo;
1:2:3:4
9:2:4:5
&amp;hellip;
45:23:545:121
&amp;ldquo;
这样，我们就可以对数据进行如下操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;fstream&amp;gt;
std::ifstream input_file(&amp;quot;a.txt&amp;quot;);
int num;
char c;
input_file &amp;gt;&amp;gt; num &amp;gt;&amp;gt; c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时num=1，c=&amp;rsquo;:&amp;lsquo;,这样我们就可以一直读下去，一直到文件末尾：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (!input_file.eof())
     do something
input_file.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要对已经读进来的文件内容进行一行一行的读取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (getline(input_file, line)) {
     cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl; // 文件每一行的数据都保存在line中
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ofstream&#34;&gt;ofstream&lt;/h2&gt;

&lt;p&gt;ofstream 与 ifstream类似，只不过一个是对文件进行读操作，一个对文件进行写操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;fstream&amp;gt;
std::ofstream out_file(&amp;quot;a.txt&amp;quot;);
int num = 4;
char c  =&#39;:&#39;;
out_file &amp;gt;&amp;gt; num &amp;gt;&amp;gt; c &amp;gt;&amp;gt; std::endl;
out_file.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果a.txt不存在，那么程序将会新建一个，如果存在，程序将会在每一次重新定义的时候，清空文件，意思就是说，当我们对文件写入完数据后，关闭然后重新打开再进行写入数据的话，会覆盖掉原来的数据。&lt;/p&gt;

&lt;h2 id=&#34;open函数&#34;&gt;open函数&lt;/h2&gt;

&lt;p&gt;我们前面都是直接在定义文件流对象时默认的给出了文件的名字，如果我们定义了一个空的文件流对象，随后可以用open函数将它与文件关联起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::ifstream input_file;
input_file.open(&amp;quot;a.txt&amp;quot;);
if (input_file)//检查open是否成功
     do something //成功可以对文件进行操作了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于ofstream同样适用。&lt;/p&gt;

&lt;h2 id=&#34;文件模式&#34;&gt;文件模式&lt;/h2&gt;

&lt;p&gt;每个流都有自己的文件模式，用来指定如何使用文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt;   &lt;em&gt;已读方式打开&lt;/em&gt;  只可以对ifstream或fstream对象设定in模式，ifstream的默认属性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;out&lt;/strong&gt;  &lt;em&gt;已写方式打开&lt;/em&gt;  只可以对outfstream或fstream对象设定out模式，ofstream的默认属性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;app&lt;/strong&gt;  每次写操作前均定位到文件末尾为了保留已out模式打开的文件内容，必须指定app模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;ate&lt;/strong&gt;  打开文件后立即定位到文件末尾&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;trunc&lt;/strong&gt;  截断文件默认属性，若没有指明文件模式，已out模式打开的文件也会被截断&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;binary&lt;/strong&gt; 已二进制文件进行IO&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面说过，若是重复对一个文件进行写操作，会造成已有数据的丢失，若不想丢失数据，需指定app模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::ofstream out;
out.open(&amp;quot;a.txt&amp;quot;,ofstream::app);
if (out)
     do something
out.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样文件中已有的数据被保存，所有写操作都是在文件末尾进行。&lt;/p&gt;

&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;fstream是可以执行ofstream和ifstream的所有操作的，但我们更希望术业有专攻，在只需要读时，使用ifstream，只需要写时，使用ofstream，只有同时需要读写时，使用fstream&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另外每一个文件在open操作完成后，都要进行close操作&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43;里一些类型之间的简单转换</title>
      <link>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 30 May 2016 20:08:13 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>

&lt;h2 id=&#34;char-string&#34;&gt;char -&amp;gt; string：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//stringstream 在头文件 sstream里面
char c;
string str;
stringstream stream;
stream &amp;lt;&amp;lt; c;
str = stream.str();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;char-string-1&#34;&gt;char * -&amp;gt; string:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;char *ch = &amp;quot;hello world&amp;quot;;
string s(ch);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;int-char&#34;&gt;int &amp;lt;-&amp;gt; char:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;int a;
char ac;
a = ac -&#39;0&#39;;
ac = a + &#39;0&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;int-string&#34;&gt;int -&amp;gt; string:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//第一种方法
int i;
string str;
stringstream stream;
stream &amp;lt;&amp;lt; i;
str = stream.str();
//C++ 11推荐的方法
int i;
string str;
str = to_string(i);
//利用sprintf,buf先为一个字符数组，然后再直接转换为string
sprintf(buf, &amp;quot;%d&amp;quot;, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-int&#34;&gt;string -&amp;gt; int:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;string s = &amp;quot;345&amp;quot;;
int i = stoi(s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;char-int&#34;&gt;char * -&amp;gt; int&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;char *c = &amp;quot;hello&amp;quot;;
int i = atoi(c);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;大小写字符相互转换&#34;&gt;大小写字符相互转换：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;char c = &#39;A&#39;;
c = tolower(c);//c = &#39;a&#39;
c = toupper(c);//c = &#39;A&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c-中string类型的大小写转换&#34;&gt;C++中string类型的大小写转换：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;string s = &amp;quot;ABCD&amp;quot;;
transform(s.begin(),s.end(),s.begin(),::tolower);// s = &amp;quot;abcd&amp;quot;
transform(s.begin(),s.end(),s.begin(),::toupper);// s = &amp;quot;ABCD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43;内存管理</title>
      <link>https://shiweihou.github.io/cplusplus/c&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 30 May 2016 13:01:02 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/c&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;&lt;strong&gt;C++中内存分配方式&lt;/strong&gt;
在c++中，内存分成5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后这些存储单元被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。&lt;/li&gt;
&lt;li&gt;堆：堆就是由malloc分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个malloc就要对应一个free。如果程序员没有释放掉，有可能在程序运行过程中会造成内存不足。程序结束后，操作系统会自动回收。&lt;/li&gt;
&lt;li&gt;自由存储区：就是由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，有可能在程序运行过程中会造成内存不足。程序结束后，操作系统会自动回收。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在C语言中，全局变量又分为初始化和未初始化的，C++里就没有这个区分了&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量，不允许修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：关于堆和自由存储区的区别，网上大部分人认为堆可以是自由存储区，但自由存储区有可能会变成静态存储区。其实在《c++ Primer 5th》中文版中，第400页说明计算机中堆和自由存储区可以视为同一个东西。我们需要搞清楚的是堆和栈的区别，至于堆和自由存储区的区别，可以不用过多考虑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堆与栈的区别&lt;/strong&gt;
网上有关堆和栈的区别讨论有很多，其实我们可以简单的认为，栈是程序在为代码中的对象生成需要时分配的空间，而堆是我们人为的想要申请一个动态内存，显示的提出申请，程序为我们提供的内存空间。例如
int *p = new int[5];
p是一个指向5个整型大小的数组的指针，看到new，我们就知道程序在堆内存上分配了一块内存，但是p确是分配的一个栈内存。所以其实是“在栈内存中存放了一个指向堆内存的指针p”。栈内存上的变量符合作用域规则，即“对于栈对象，仅在其定义的程序块运行时才存在，离开作用域，其隐式自动的被销毁；对于堆对象，当我们不需要时，必须显示的销毁它”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;控制C++的内存分配&lt;/strong&gt;&lt;br /&gt;
若想安全的使用c++内存，必须要保证程序的堆内存是安全的。意思是说，如果生成了一块堆内存，那么我们就必须要显示的销毁它。最简单的来讲，就是malloc和free要成对出现，new和delete要成对出现，如果有一个没有满足要求，就有可能发生内存泄漏或者造成其它方面的错误等原因。记住，一个new，后面一个delete；一个malloc，后面一个free。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的内存错误及对策&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内存分配未成功，确使用了它。 解决方法：使用内存前判断指针是否为NULL。&lt;/li&gt;
&lt;li&gt;内存分配成功，但尚未初始化就使用。出现这种问题，很多时候都是因为误以为内存的默认初始值都是0.解决方法：显示的进行初始化，不执行默认初始化，宁愿麻烦点，也保证不要出错。&lt;/li&gt;
&lt;li&gt;内存分配成功并正确初始化，但使用时越界。这个问题更常见，很多时候你分配了只有10个内存大小，但你使用第11个内存、第12个内存，就很容易发生这种错误。解决方法:仔细检查！&lt;/li&gt;
&lt;li&gt;忘记释放内存，造成内存泄漏。解决方法：一个new-&amp;gt;delete, 一个malloc-&amp;gt;free。不要想着拆散他们&lt;/li&gt;
&lt;li&gt;内存已释放，却还要继续使用他们。一个内存已经delete或者free掉了，好比一个人已经从北京离开到上海了，你还要人家在北京帮你买东西，这不扯淡吗&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不要怕指针，指针其实很简单。写程序时多细心点，出错时逐步检查，一般而言都是可以解决问题的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基类派生类的一些问题</title>
      <link>https://shiweihou.github.io/cplusplus/C&#43;&#43;%20%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 17 May 2016 19:08:13 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/C&#43;&#43;%20%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;C++中构造函数初始化时必须采用初始化列表的一共有三种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要初始化的数据成员是对象（继承时调用基类构造函数）&lt;/li&gt;
&lt;li&gt;需要初始化const修饰的类成员&lt;/li&gt;
&lt;li&gt;需要初始化引用成员数据&lt;/li&gt;
&lt;li&gt;因为static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的，static const成员也一样，不允许在类内初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;C++ 的构造函数没有办法被派生类所继承，但可以被派生类调用。构造原则如下&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果子类没有定义构造方法，则调用父类的无参数的构造方法。&lt;/li&gt;
&lt;li&gt;如果子类定义了构造方法，无论是有参数还是无参数，在创建子类对象的时候，首先执行父类的无参构造方法，然后执行自己的构造方法。&lt;/li&gt;
&lt;li&gt;在创建子类对象时候，如果子类的构造函数没有显式调用父类的构造函数，则会调用父类的无参构造函数。&lt;/li&gt;
&lt;li&gt;在创建子类对象时候，如果子类的构造函数没有显式调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错，子类必须显式调用此带参构造方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在C++中，构造函数无法被声明为虚函数，但析构函数可以。并且如果某个类作为基类，其析构函数最好还是声明为虚析构函数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用Hugo在GitHub上建立个人博客</title>
      <link>https://shiweihou.github.io/about/</link>
      <pubDate>Sat, 09 Apr 2016 10:54:16 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/about/</guid>
      <description>

&lt;p&gt;使用Hugo和GitHub生成个人博客。
本人完全新手，弄了2天，一直出现各种问题，现在终于基本搞定。现将基本流程告知如下，后续补充。
本人工作环境：Windows10 + hugo  + go  + mercurial + git&lt;/p&gt;

&lt;p&gt;安装前建议：自己学会GitHub及git的简单用法，推荐一个git的&lt;a href=&#34;http://www.bootcss.com/p/git-guide/&#34;&gt;简易教程网站&lt;/a&gt;，强烈简易看懂git的用法，这样如果中间出了什么问题也可以解决。另，善用搜索引擎。&lt;/p&gt;

&lt;h2 id=&#34;1-配置环境&#34;&gt;1.配置环境&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;go&lt;/a&gt;语言去官网下载，找到对应的版本，下载好后直接安装，next，windows用户直接默认安装路径就行。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.mercurial-scm.org/&#34;&gt;mercurial&lt;/a&gt;同理，也是下载对应的可执行文件，下载安装，默认安装路径就行。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/&#34;&gt;git&lt;/a&gt;也是如此，去官网下载最新版本，windows上安装，next。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;hugo&lt;/a&gt;去官网下载操作系统对应的release版本。
hugo是个二进制文件，windows用户下载好之后不需要安装，将它放到一个你容易找到的文件夹内。例如我的是C:\Hugo\bin。然后设置环境变量，将C:\Hugo\bin加入到当前用户路径path中，并重启电脑。这样操作系统就能直接识别hugo命令。&lt;/p&gt;

&lt;h2 id=&#34;2-生成站点&#34;&gt;2.生成站点&lt;/h2&gt;

&lt;p&gt;你可以在你想要的目录下生成站点。我为了方便，直接放在了C:\Hugo\Sites目录下。sites目录是我新建的，和bin目录一个级别，也就是说现在Hugo文件夹现在有两个子文件夹，一个bin，一个sites，这样做是为了方便管理。然后在sites目录上，右键选择Git Bash Here,进入git命令。然后，开始生成新的站点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就在mysite目录里生成了初始站点目录mysite，进去目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到里面有已经默认创建好了4个文件夹和一个config.toml。
config.toml是网站的配置文件，包括baseurl, title, copyright等等网站参数。&lt;br /&gt;
这几个文件夹的作用分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;content：包括网站内容，全部使用markdown格式&lt;/li&gt;
&lt;li&gt;layouts：包括了网站的模版，决定内容如何呈现&lt;/li&gt;
&lt;li&gt;static：包括了css, js, fonts, media等，决定网站的外观
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接着，我们就可以在这里面创建我们需要展示的文章。&lt;/p&gt;

&lt;h2 id=&#34;3-创建文章&#34;&gt;3.创建文章&lt;/h2&gt;

&lt;p&gt;首先，我们来创建一个about页面 (在mysite目录下启动git bash)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new  about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;about.md自动生成到了content/about.md,打开about.md看下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-04-09T10:28:02+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式是markdown格式的文件。我们可以看到文件创建时的时间，页面名，是否为草稿等信息都在里面。我们可以在后面加一些内容，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-04-09T10:28:02+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;

+++
#关于本文
-nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后保存退出，运行hugo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们打开localhost:1313发现什么内容也没有，因为我们没有指定模板，退出，安装皮肤。&lt;/p&gt;

&lt;h2 id=&#34;4-安装皮肤&#34;&gt;4.安装皮肤&lt;/h2&gt;

&lt;p&gt;hugo自己有集成了很多种皮肤，可以去&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;官网&lt;/a&gt;上搜寻，找到你喜欢的皮肤。我所用的皮肤是RED LOUNGE，找到相关的GitHub地址，创建目录themes（和content这些一个级别）,在themes目录里把皮肤git clone下来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/tmaiaroto/hugo-redlounge.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次运行hugo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --theme=hugo-redlounge --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时再打开localhost:1313就能看到页面了&lt;/p&gt;

&lt;p&gt;ps：关于皮肤这块，如果每次运行时都要指定皮肤模式，很麻烦，所以有个很简单的办法。假如你很喜欢redlounge这个皮肤，然后把它git到themes文件夹中，这时redlounge文件夹内就有两个好几个子文件夹，其中包括layouts和static文件夹。你可以直接复制这两个文件夹，替换掉站点根目录下的两个对应的layouts和static文件夹，这样，下次运行的时候，只需要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就OK了。同理，如果喜欢其它的皮肤，也是如此做。&lt;/p&gt;

&lt;h2 id=&#34;5-部署到github上&#34;&gt;5.部署到GitHub上&lt;/h2&gt;

&lt;p&gt;假设你需要部署在GitHub Pages上，首先在GitHub上创建一个Repository，命名为username.github.io 例如，我的用户名为shiweiHou,所以我创建的Repository名字就为：shiweiHou.github.io&lt;/p&gt;

&lt;p&gt;注意：创建Repository时，不要选择生成readme.md选项，你如果了解git命令，在后面就能看到原因。如果你是新手，建议不要生成。&lt;/p&gt;

&lt;p&gt;在你的站点根目录下执行hugo(同样利用git bash)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo  --baseUrl=&amp;quot;http://shiweiHou.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为了方便，在每一次生成md的时候，都将文章头部的draft=true去掉，这样，就不用考虑草稿的问题。&lt;/p&gt;

&lt;p&gt;如果一切顺利，在站点根目录下会生成一个public文件夹，接着要做的事情就是将public目录所有的文件push到刚刚创建的Repository的master分支上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd public
$ git init
$ git remote add origin https://github.com/shiweiHou/shiweiHou.github.io.git
$ git add -A
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push -u origin master    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等一会，打开 &lt;a href=&#34;http://shiweiHou.github.io&#34;&gt;http://shiweiHou.github.io&lt;/a&gt; 访问你刚刚生成的界面，要将shiweiHou替换成你的用户名。&lt;/p&gt;

&lt;p&gt;续：关于生成public文件夹这块，hugo在0.15版本之后，就默认是在内存中修改而不是直接生成public文件夹在磁盘中修改。意思是说，如果你运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不会生成public文件夹，它会调用到内存中，进行修改。如果想要生成public文件夹，只需要直接运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;6-更新&#34;&gt;6.更新&lt;/h2&gt;

&lt;p&gt;在第五步的时候，我们将初始化的站点部署到了GitHub上，那么如果我修改了其中的几个文件，比如about.md,或者增加了其它的文档md，那么就需要进行更新操作。同样，我们进入站点根目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后同样，和第一次初始化的时候很像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd public
$ git init
$ git add .
$ git commit -m &amp;quot;something changed&amp;quot;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>