<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello world!</title>
    <link>https://shiweiHou.github.io/</link>
    <description>Recent content on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 25 Feb 2017 19:20:31 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>leetcode 467.Unique Substrings in Wraparound String</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-467/</link>
      <pubDate>Sat, 25 Feb 2017 19:20:31 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-467/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int findSubstringInWraproundString(string p) {
            // 一开始想法是，构建一个哈希表，&lt;string, int&gt;类型，发现不行，原因是string有可能很长而且每次都要进行查找操作，效率很低
            // 其实最主要的是WA了，也没有找出原因
            // 后来就想到，因为题目里要求每个字符串如果出现N次的话，只算1次，而且必须是挨着的。所以如果字符串 abcdefg 出现了，那么
            // abcde 就没必要计算了，因为前一个字符串包含后一个。设一个大小为26位的数组，每个数组存的是以当前下标 + &amp;lsquo;a&amp;rsquo; 的字符在p
            // 中出现的最大长度，最后将所有的加起来就行了，时间复杂度为O(N)
            vector&lt;int&gt; letters(26, 0);
            int len = 0;
            for (int i = 0; i &amp;lt; p.size(); ++i) {
                int cur = p[i] - &amp;lsquo;a&amp;rsquo;; // 当前字符是哪一个
                // 已当前字符为开始的最大顺序长度，没有就为1，因为本身也算1个
                if (i &amp;gt; 0 &amp;amp;&amp;amp; p[i - 1] != (cur + 25) % 26 + &amp;lsquo;a&amp;rsquo;) len = 1;
                else ++len;
                if (len &amp;gt; letters[cur]) letters[cur] = len;
            }
            int ret = 0;
            for (auto i : letters) ret += i;
            return ret;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 468. Validate ip address</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-468/</link>
      <pubDate>Sat, 25 Feb 2017 15:31:07 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-468/</guid>
      <description>&lt;p&gt;// 这道题学到的就是getline函数不仅可以读取输入的一整行字符串，也可以将已有的字符串
    // 转换为stringstream流，这样利用getline函数就可以每次读几个字符直到碰到指定字符，然后跳过该指定字符继续
    // 往后读。C++11里对getline函数有两个原型，一个是
    // 1. istream&amp;amp; getline (istream&amp;amp;  is, string&amp;amp; str, char delim);另一个是
    // 2. istream&amp;amp; getline (istream&amp;amp;  is, string&amp;amp; str);
    // 2是我们最常用的，就是从键盘输入一串字符，getline一直在stream流内读，直到碰到&amp;rsquo;\n&amp;rsquo;
    // 而1则是截取特定字符串，也是从前往后读，直到碰到字符 delim 为止
    class Solution {
    public:
        const string validIPv6Chars = &amp;ldquo;0123456789abcdefABCDEF&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool isValidIPv4Block(string&amp;amp; block) {
        int num = 0;
        if (block.size() &amp;gt; 0 &amp;amp;&amp;amp; block.size() &amp;lt;= 3) {
            for (int i = 0; i &amp;lt; block.size(); i++) {
                char c = block[i];
                // special case: if c is a leading zero and there are characters left
                // 用于规避出现前导0的情况
                if (!isalnum(c) || (i == 0 &amp;amp;&amp;amp; c == &#39;0&#39; &amp;amp;&amp;amp; block.size() &amp;gt; 1))
                return false;
                else {
                    num *= 10;
                    num += c - &#39;0&#39;;
                }
            }
            return num &amp;lt;= 255;
        }
        return false;
    }

    bool isValidIPv6Block(string&amp;amp; block) {
        if (block.size() &amp;gt; 0 &amp;amp;&amp;amp; block.size() &amp;lt;= 4) {
            for (int i = 0; i &amp;lt; block.size(); i++) {
                char c = block[i];
                if (validIPv6Chars.find(c) == string::npos)
                    return false;
            }
            return true;
        }
        return false;
    }

    string validIPAddress(string IP) {

        string ans[3] = {&amp;quot;IPv4&amp;quot;, &amp;quot;IPv6&amp;quot;, &amp;quot;Neither&amp;quot;};
        // 将string变成stringstream流，这样就可以利用getline函数，每一次将.字符之前的字符保存下来，放进block内
        stringstream ss(IP);
        string block;
        // ipv4 candidate
        if (IP.substr(0, 4).find(&#39;.&#39;) != string::npos) {
            for (int i = 0; i &amp;lt; 4; i++) {
            if (!getline(ss, block, &#39;.&#39;) || !isValidIPv4Block(block))
                return ans[2];
            }
            // 用于判断stringstream流是否走到了尽头，即是否完全处理了IP
            return ss.eof() ? ans[0] : ans[2];
        }
        // ipv6 candidate
        else if (IP.substr(0, 5).find(&#39;:&#39;) != string::npos) {
            for (int i = 0; i &amp;lt; 8; i++) {
            if (!getline(ss, block, &#39;:&#39;) || !isValidIPv6Block(block))
                return ans[2];
            }
            return ss.eof() ? ans[1] : ans[2];
        }

        return ans[2];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 401.Binary Watch</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-401/</link>
      <pubDate>Fri, 24 Feb 2017 21:34:34 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-401/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; readBinaryWatch(int num) {
            int h[] = {1, 2, 4, 8};
            int m[] = {1, 2, 4, 8, 16,32};
            if (num &amp;gt; 10) num = 10;
            vector&lt;string&gt; ret;
            if (num == 0) { ret.push&lt;em&gt;back(&amp;ldquo;0:00&amp;rdquo;); return ret;}
            // 限制条件老是写错，出了一大堆的bug，烦烦烦烦烦烦
            for (int i = 0; i &amp;lt; 4 &amp;amp;&amp;amp; i &amp;lt;= num; ++i) {
                int j = num - i;
                if (j &amp;gt; 5) continue;
                // i, j is all possible num
                vector&lt;string&gt; hours;
                vector&lt;string&gt; minutes;
                // find hours
                find&lt;/em&gt;(hours, h, 0, 0, 0, i);
                // find minutes
                find_2(minutes, m, 0, 0, 0, j);
                if (hours.empty() &amp;amp;&amp;amp; !minutes.empty()){
                    for(auto min : minutes) {
                        ret.push_back(&amp;ldquo;0:&amp;rdquo; + min);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; minutes.empty()){
                    for (auto hour : hours) {
                        ret.push_back(hour + &amp;ldquo;:00&amp;rdquo;);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; !minutes.empty()) {
                    for (auto hour : hours){
                        for (auto min : minutes) {
                            ret.push_back(hour + &amp;ldquo;:&amp;rdquo; + min);
                        }
                    }
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            hours.clear();
            minutes.clear();

        }

        return ret;
    }
    // cur 表示当前用了几个数，sum表示当前的和，pos表示搜索到的下标位置，all表示一共要选取几个数
    void find_(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 4 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 12) {
            vs.push_back(to_string(sum));
        }
        if (sum &amp;gt;= 12) return;
        find_(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_(vs, h, cur, sum, pos + 1, all);
    }
    void find_2(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 6 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 60) {
            if (sum &amp;gt;= 10){
               vs.push_back(to_string(sum)); 
            } else {
                vs.push_back(&amp;quot;0&amp;quot; + to_string(sum));
            }
        }
        if (sum &amp;gt;= 60) return;
        find_2(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_2(vs, h, cur, sum, pos + 1, all);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 409.Longest Palindrome</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-409/</link>
      <pubDate>Fri, 24 Feb 2017 21:32:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-409/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int longestPalindrome(string s) {
            vector&lt;int&gt; vc(60, 0);
            int i = 0;
            while (i &amp;lt; s.size()) {
                ++vc[s[i]-&amp;lsquo;A&amp;rsquo;];
                ++i;
            }
            i = 0;
            int len = 0;
            while (i &amp;lt; 60) {
                if (vc[i] != 0 &amp;amp;&amp;amp; vc[i] % 2 == 0) {
                    len += vc[i];
                    vc[i] = 0;
                }
    // 一开始想错了，以为是奇数个的，只能用最多的那个奇数，其实所有出现次数大于1的奇数，都可以通过减1变成偶数个从而加入最长回文串内
                if (vc[i] % 2 == 1 &amp;amp;&amp;amp; vc[i] &amp;gt; 1) {
                    len += vc[i] - 1;
                    vc[i] = 1;
                }
                ++i;
            }
            i = 0; // 所有的遍历完之后，发现还有有的数还有一次机会，那就放到最中间去，len++，变成最长回文串
            while (i &amp;lt; 60) {
                if (vc[i] != 0) {
                    ++len;
                    break;
                }
                ++i;
            }
            return len ;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 453.Minimum Moves to Equal Array Elements</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-453/</link>
      <pubDate>Fri, 24 Feb 2017 21:28:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-453/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int minMoves(vector&lt;int&gt;&amp;amp; nums) {
            // 假设经过M次移动后，所有的数为同一个值，为X，原先数组的和为SUM，最小值为minNum,则此时有公式
            // sum + M * (n - 1) = X * n;
            // 而 X 其实是等于最小的那个数加了M次 X = minNum + M
            // 带入化简，得到 M = sum - minNum * n;
            int sum = 0;
            int minNum = nums[0];
            int i = 0;
            while (i &amp;lt; nums.size()) {
                sum += nums[i];
                minNum = min(minNum, nums[i]);
                ++i;
            }
            return sum - minNum * nums.size();
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 476.Number Complement</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-476/</link>
      <pubDate>Fri, 24 Feb 2017 21:26:30 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-476/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int findComplement(int num) {
            // 这个是最笨的一种方法，就是首先将num右移，查看num去除前缀0之后有效位有几位
            // 然后再重新遍历一边num的末尾数字，根据有效位的个数控制右移几次，还利用了pow函数
            // 网上有一种最简单的，其实上面的那种方法，也是根据后几位来求，假如后4位为有效位
            // 那么我们如果能得到一个 后四位为0前面几位都为1的数，和num进行分别取反进行&amp;amp;操作就可以
            // mask = ~0;
            // while (mask &amp;amp; num) mask = mask &amp;lt;&amp;lt; 1;
            // return ~num &amp;amp; ~mask
            // 例如            num =  0000 0101
            // 经过while循环， mask = 1111 1000
            // ~num &amp;amp; ~mask = 0000 0010 = 2
            int n = 0;
            int num1 = num;
            while (num1) {
                ++n;
                num1 = num1 &amp;gt;&amp;gt; 1;
            }
            int ret = 0, i = 0;
            while(i &amp;lt; n) {
                int a = num &amp;amp; 1;
                ret += (a == 1? 0 : 1) * pow(2,i);
                ++i;
                num = num &amp;gt;&amp;gt; 1;
            }
            return ret;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 506.Relative Ranks</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-506/</link>
      <pubDate>Fri, 24 Feb 2017 21:20:31 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-506/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp;amp; nums) {
            // 先求出最大值，然后遍历查询比当前数大的数有几个
            // 多此一举了，不需要求最大值，直接遍历就行，还是想的多了
            int max_num = nums[0];
            int i = 1;
            while (i &amp;lt; nums.size()) {
                max_num = max(max_num, nums[i]);
                ++i;
            }
            i = 0;
            vector&lt;string&gt; ret;
            while (i &amp;lt; nums.size()) {
                nums[i] = max_num - nums[i];
                ++i;
            }
            i = 0;
            while (i &amp;lt; nums.size()) {
                int count = order(nums, i);
                if (count == 0) ret.push_back(&amp;ldquo;Gold Medal&amp;rdquo;);
                else if (count == 1) ret.push_back(&amp;ldquo;Silver Medal&amp;rdquo;);
                else if (count == 2) ret.push_back(&amp;ldquo;Bronze Medal&amp;rdquo;);
                else ret.push_back(to_string(count + 1));
                ++i;
            }
            return ret;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    int order(vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos) {
        int count = 0;
        int i = 0;
        while (i &amp;lt; nums.size()) {
            if (i != pos &amp;amp;&amp;amp; nums[pos] &amp;gt; nums[i]) ++count;
            ++i;
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 12 &amp; 13 </title>
      <link>https://shiweihou.github.io/lintcode/leetcode-12/</link>
      <pubDate>Fri, 24 Feb 2017 21:16:03 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-12/</guid>
      <description>&lt;p&gt;数字转换为罗马数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string intToRoman(int num) {
        string M[] = {&amp;quot;&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;MM&amp;quot;, &amp;quot;MMM&amp;quot;};//0 1000 2000 3000
        string C[] = {&amp;quot;&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;CC&amp;quot;, &amp;quot;CCC&amp;quot;, &amp;quot;CD&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;DC&amp;quot;, &amp;quot;DCC&amp;quot;, &amp;quot;DCCC&amp;quot;, &amp;quot;CM&amp;quot;};// 0 100 200 300 400 500 600 700 800 900
        string X[] = {&amp;quot;&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;XX&amp;quot;, &amp;quot;XXX&amp;quot;, &amp;quot;XL&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;LX&amp;quot;, &amp;quot;LXX&amp;quot;, &amp;quot;LXXX&amp;quot;, &amp;quot;XC&amp;quot;};// 0 10 20 30 40 50 60 70 80 90
        string I[] = {&amp;quot;&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;II&amp;quot;, &amp;quot;III&amp;quot;, &amp;quot;IV&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;VI&amp;quot;, &amp;quot;VII&amp;quot;, &amp;quot;VIII&amp;quot;, &amp;quot;IX&amp;quot;};// 0 1 2 3 4 5 6 7 8 9

        return M[num / 1000] + C[num % 1000 / 100] + X[num % 100 / 10] + I[num % 10];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;罗马数字转换为数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int romanToInt(string s) {
        unordered_map&amp;lt;char, int&amp;gt; T = { { &#39;I&#39; , 1 },
                                    { &#39;V&#39; , 5 },
                                   { &#39;X&#39; , 10 },
                                   { &#39;L&#39; , 50 },
                                   { &#39;C&#39; , 100 },
                                   { &#39;D&#39; , 500 },
                                   { &#39;M&#39; , 1000 } };

        int sum = T[s.back()];
        for (int i = s.length() - 2; i &amp;gt;= 0; --i) 
        {
            // 根据罗马数字左减右加原则
            if (T[s[i]] &amp;lt; T[s[i + 1]])
            {
                sum -= T[s[i]];
            }
            else
            {
                sum += T[s[i]];
            }
        }

        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 461.Hamming Distance</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-461/</link>
      <pubDate>Fri, 24 Feb 2017 21:04:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-461/</guid>
      <description>&lt;p&gt;题目要求求出两个非负数之间二进制对应位不同值是多少，例如1对应二进制为 0 0 0 1（后四位），4对应二进制为 0 1 0 0，那么不同值就是2，从右往前看是第1位与第三位不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int hammingDistance(int x, int y) {
        int count = 0;
        // 最朴素的一种做法，就是每次求得两个数的最后一个比特位，然后比较，然后两个数右移
        while (x || y) { // 当x和y全部为0时才退出循环
            int a = x &amp;amp; 1; // 找到x和y二进制最后一位的数到底时0还是1
            int b = y &amp;amp; 1;
            if (a != b) ++count;
            x = x &amp;gt;&amp;gt; 1; // x右移一位
            y = y &amp;gt;&amp;gt; 1; // y右移一位
        }
        // 还有一种更简单的做法，就是将x^y的值求出来，求结果中有多少个1，那么就是答案
        // count = 0;
        // int n = x ^ y;
        // while (n) {
        //    ++count;
        //    n &amp;amp;= n - 1;
        // }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题7</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%987/</link>
      <pubDate>Wed, 15 Feb 2017 11:29:12 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%987/</guid>
      <description>&lt;p&gt;计算糖果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int main() {
    int a, b, c, d;
    int A, B, C;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;
    A = (a + c) / 2;
    B = A - a;
    C = B - b;
    if (A &amp;gt;= 0 &amp;amp;&amp;amp; B &amp;gt;= 0 &amp;amp;&amp;amp; C &amp;gt;=0 &amp;amp;&amp;amp; (A-B) == a &amp;amp;&amp;amp; (B-C) == b &amp;amp;&amp;amp; (A+B) == c &amp;amp;&amp;amp; (B+C) == d) cout &amp;lt;&amp;lt; A &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; B &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; C &amp;lt;&amp;lt; endl;
    else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题6</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</link>
      <pubDate>Wed, 15 Feb 2017 11:28:33 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</guid>
      <description>&lt;p&gt;买苹果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    if (n &amp;lt; 6 || n == 7) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    else {
        int n8 = n / 8, n6 ;

        if (n % 8 == 0) n6 = 0;
        else n6 = 1;

        while ( n8 * 8 + n6 * 6 &amp;gt; n) {
            --n8;
            ++n6;
        }

        if (n8 * 8 + n6 * 6 == n) cout &amp;lt;&amp;lt; n6 + n8 &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题5</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</link>
      <pubDate>Wed, 15 Feb 2017 11:18:02 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</guid>
      <description>&lt;p&gt;最大奇约数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
/*思路：
*如果是奇数，直接加上去就行了，如果是偶数，就需要一直除2把它变成奇数，如果直接一个
*一个的加，会超时，因此需要用到一些技巧
*例如，N = 10，那么我们此时一共有 1 2 3 4 5 6 7 8 9 10十个数，里面有10/2=5个奇数 1 3 5 7 9，那么奇数项的和为
*一个等差数列公式：s = n * a1 + (n * (n-1) / 2) * d,其中a1为第一项，n为个数，其实是N/2，d为2，那么我们套用进去
*s = N / 2 + (N / 2) * (N / 2 -1) / 2 * 2 = (N / 2) * (N / 2),又因为当N为奇数的时候，N / 2 == （N + 1） / 2
*所以不管是奇数偶数，都可以用 ((N+1) / 2) * ((N+1) / 2)这个公式求和
*这样我们每一次都把1~N的奇数项求和，剩下的是偶数项，继续 N= N/2 (因为 1 2 3 4 5 6 7 8 9 10将奇数项去掉后
*，还剩下 2 4 6 8 10，他们的最大奇约数其实就是 1 2 3 4 5的最大奇约数，所以求N/2的和就行了）求 1~N 的和，直到0
*/
int main() {
    long long N, sum = 0;
    cin &amp;gt;&amp;gt; N;
    for (long long i = N; i &amp;gt; 0; i /= 2) {
        sum += ((i+1) / 2) * ((i+1) / 2);
    }
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题4</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</link>
      <pubDate>Wed, 15 Feb 2017 11:00:24 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</guid>
      <description>&lt;p&gt;数字翻转：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

int rev(int num){
    vector&amp;lt;int&amp;gt; digit; 
    int t = 0; // 记录位数
    while (num) {
        digit.push_back(num % 10);
        num /= 10;
        ++t;
    }
    num = 0;
    for (int i = 0; i &amp;lt; t ; ++i) {
        num = num * 10 + digit[i];
    }
    return num;
}

int main() {
    int x, y;
    cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
    cout &amp;lt;&amp;lt; rev(rev(x) + rev(y)) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题3</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</link>
      <pubDate>Wed, 15 Feb 2017 10:53:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</guid>
      <description>&lt;p&gt;跳石板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

void find_yue_shu(int num, vector&amp;lt;int&amp;gt; &amp;amp;yue_shu) {
    for (int i = 2; i &amp;lt;= sqrt(num); ++i) {
        if (num % i == 0) {
            yue_shu.push_back(i);
            if (num / i != i) yue_shu.push_back(num / i);
        }
    }

}

int fuc(int N, int M) {
    if (N == M) return 0;
    vector&amp;lt;int&amp;gt; dp(M+1, -1);
    dp[N] = 0;
    for (int i = N; i &amp;lt;= M; ++i) {
        if (dp[i] == -1) continue; // 说明该点无法到达
        vector&amp;lt;int&amp;gt; yue_shu;
        find_yue_shu(i, yue_shu);
        for (int j = 0; j &amp;lt; yue_shu.size(); ++j) {
            int pos = yue_shu[j] + i; // 根据这个约数能到达的台阶位置
            if (pos &amp;lt;= M &amp;amp;&amp;amp; dp[pos] != -1) { // 这个位置小于M，并且该位置已经可以到达了，就要进行比较,否则直接+1
                dp[pos] = min(dp[pos] , dp[i] + 1);
            } else if (pos &amp;lt;= M) {
                dp[pos] = dp[i] + 1;
            }
        }
    }

    if (dp[M] == -1) return -1;
    return dp[M];
}

int main() {
    int N, M;
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;
    cout &amp;lt;&amp;lt; fuc(N, M) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题2</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</link>
      <pubDate>Wed, 15 Feb 2017 10:30:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</guid>
      <description>&lt;p&gt;优雅的点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int rr;
    cin &amp;gt;&amp;gt; rr;
    int r = (int)sqrt(rr);
    int sum = 0;

    for (int i = r; i &amp;gt;= 0; --i) {
        // 只计算第一象限的点
        int j = (int)sqrt(rr - i * i);
        if (i * i + j * j == rr) ++sum;
    }
    sum *= 4;
    // 如果半径本身就是整数点，那么相当于重复计算了四个轴的四个点，需要减去4
    if (r * r == rr) sum -= 4;
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>