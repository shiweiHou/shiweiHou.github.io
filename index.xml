<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello world!</title>
    <link>https://shiweiHou.github.io/</link>
    <description>Recent content on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 24 Feb 2017 21:34:34 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>leetcode 401.Binary Watch</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-401/</link>
      <pubDate>Fri, 24 Feb 2017 21:34:34 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-401/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; readBinaryWatch(int num) {
            int h[] = {1, 2, 4, 8};
            int m[] = {1, 2, 4, 8, 16,32};
            if (num &amp;gt; 10) num = 10;
            vector&lt;string&gt; ret;
            if (num == 0) { ret.push&lt;em&gt;back(&amp;ldquo;0:00&amp;rdquo;); return ret;}
            // 限制条件老是写错，出了一大堆的bug，烦烦烦烦烦烦
            for (int i = 0; i &amp;lt; 4 &amp;amp;&amp;amp; i &amp;lt;= num; ++i) {
                int j = num - i;
                if (j &amp;gt; 5) continue;
                // i, j is all possible num
                vector&lt;string&gt; hours;
                vector&lt;string&gt; minutes;
                // find hours
                find&lt;/em&gt;(hours, h, 0, 0, 0, i);
                // find minutes
                find_2(minutes, m, 0, 0, 0, j);
                if (hours.empty() &amp;amp;&amp;amp; !minutes.empty()){
                    for(auto min : minutes) {
                        ret.push_back(&amp;ldquo;0:&amp;rdquo; + min);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; minutes.empty()){
                    for (auto hour : hours) {
                        ret.push_back(hour + &amp;ldquo;:00&amp;rdquo;);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; !minutes.empty()) {
                    for (auto hour : hours){
                        for (auto min : minutes) {
                            ret.push_back(hour + &amp;ldquo;:&amp;rdquo; + min);
                        }
                    }
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            hours.clear();
            minutes.clear();

        }

        return ret;
    }
    // cur 表示当前用了几个数，sum表示当前的和，pos表示搜索到的下标位置，all表示一共要选取几个数
    void find_(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 4 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 12) {
            vs.push_back(to_string(sum));
        }
        if (sum &amp;gt;= 12) return;
        find_(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_(vs, h, cur, sum, pos + 1, all);
    }
    void find_2(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 6 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 60) {
            if (sum &amp;gt;= 10){
               vs.push_back(to_string(sum)); 
            } else {
                vs.push_back(&amp;quot;0&amp;quot; + to_string(sum));
            }
        }
        if (sum &amp;gt;= 60) return;
        find_2(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_2(vs, h, cur, sum, pos + 1, all);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 409.Longest Palindrome</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-409/</link>
      <pubDate>Fri, 24 Feb 2017 21:32:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-409/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int longestPalindrome(string s) {
            vector&lt;int&gt; vc(60, 0);
            int i = 0;
            while (i &amp;lt; s.size()) {
                ++vc[s[i]-&amp;lsquo;A&amp;rsquo;];
                ++i;
            }
            i = 0;
            int len = 0;
            while (i &amp;lt; 60) {
                if (vc[i] != 0 &amp;amp;&amp;amp; vc[i] % 2 == 0) {
                    len += vc[i];
                    vc[i] = 0;
                }
    // 一开始想错了，以为是奇数个的，只能用最多的那个奇数，其实所有出现次数大于1的奇数，都可以通过减1变成偶数个从而加入最长回文串内
                if (vc[i] % 2 == 1 &amp;amp;&amp;amp; vc[i] &amp;gt; 1) {
                    len += vc[i] - 1;
                    vc[i] = 1;
                }
                ++i;
            }
            i = 0; // 所有的遍历完之后，发现还有有的数还有一次机会，那就放到最中间去，len++，变成最长回文串
            while (i &amp;lt; 60) {
                if (vc[i] != 0) {
                    ++len;
                    break;
                }
                ++i;
            }
            return len ;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 453.Minimum Moves to Equal Array Elements</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-453/</link>
      <pubDate>Fri, 24 Feb 2017 21:28:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-453/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int minMoves(vector&lt;int&gt;&amp;amp; nums) {
            // 假设经过M次移动后，所有的数为同一个值，为X，原先数组的和为SUM，最小值为minNum,则此时有公式
            // sum + M * (n - 1) = X * n;
            // 而 X 其实是等于最小的那个数加了M次 X = minNum + M
            // 带入化简，得到 M = sum - minNum * n;
            int sum = 0;
            int minNum = nums[0];
            int i = 0;
            while (i &amp;lt; nums.size()) {
                sum += nums[i];
                minNum = min(minNum, nums[i]);
                ++i;
            }
            return sum - minNum * nums.size();
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 476.Number Complement</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-476/</link>
      <pubDate>Fri, 24 Feb 2017 21:26:30 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-476/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int findComplement(int num) {
            // 这个是最笨的一种方法，就是首先将num右移，查看num去除前缀0之后有效位有几位
            // 然后再重新遍历一边num的末尾数字，根据有效位的个数控制右移几次，还利用了pow函数
            // 网上有一种最简单的，其实上面的那种方法，也是根据后几位来求，假如后4位为有效位
            // 那么我们如果能得到一个 后四位为0前面几位都为1的数，和num进行分别取反进行&amp;amp;操作就可以
            // mask = ~0;
            // while (mask &amp;amp; num) mask = mask &amp;lt;&amp;lt; 1;
            // return ~num &amp;amp; ~mask
            // 例如            num =  0000 0101
            // 经过while循环， mask = 1111 1000
            // ~num &amp;amp; ~mask = 0000 0010 = 2
            int n = 0;
            int num1 = num;
            while (num1) {
                ++n;
                num1 = num1 &amp;gt;&amp;gt; 1;
            }
            int ret = 0, i = 0;
            while(i &amp;lt; n) {
                int a = num &amp;amp; 1;
                ret += (a == 1? 0 : 1) * pow(2,i);
                ++i;
                num = num &amp;gt;&amp;gt; 1;
            }
            return ret;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 506.Relative Ranks</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-506/</link>
      <pubDate>Fri, 24 Feb 2017 21:20:31 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-506/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp;amp; nums) {
            // 先求出最大值，然后遍历查询比当前数大的数有几个
            // 多此一举了，不需要求最大值，直接遍历就行，还是想的多了
            int max_num = nums[0];
            int i = 1;
            while (i &amp;lt; nums.size()) {
                max_num = max(max_num, nums[i]);
                ++i;
            }
            i = 0;
            vector&lt;string&gt; ret;
            while (i &amp;lt; nums.size()) {
                nums[i] = max_num - nums[i];
                ++i;
            }
            i = 0;
            while (i &amp;lt; nums.size()) {
                int count = order(nums, i);
                if (count == 0) ret.push_back(&amp;ldquo;Gold Medal&amp;rdquo;);
                else if (count == 1) ret.push_back(&amp;ldquo;Silver Medal&amp;rdquo;);
                else if (count == 2) ret.push_back(&amp;ldquo;Bronze Medal&amp;rdquo;);
                else ret.push_back(to_string(count + 1));
                ++i;
            }
            return ret;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    int order(vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos) {
        int count = 0;
        int i = 0;
        while (i &amp;lt; nums.size()) {
            if (i != pos &amp;amp;&amp;amp; nums[pos] &amp;gt; nums[i]) ++count;
            ++i;
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 12 &amp; 13 </title>
      <link>https://shiweihou.github.io/lintcode/leetcode-12/</link>
      <pubDate>Fri, 24 Feb 2017 21:16:03 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-12/</guid>
      <description>&lt;p&gt;数字转换为罗马数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string intToRoman(int num) {
        string M[] = {&amp;quot;&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;MM&amp;quot;, &amp;quot;MMM&amp;quot;};//0 1000 2000 3000
        string C[] = {&amp;quot;&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;CC&amp;quot;, &amp;quot;CCC&amp;quot;, &amp;quot;CD&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;DC&amp;quot;, &amp;quot;DCC&amp;quot;, &amp;quot;DCCC&amp;quot;, &amp;quot;CM&amp;quot;};// 0 100 200 300 400 500 600 700 800 900
        string X[] = {&amp;quot;&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;XX&amp;quot;, &amp;quot;XXX&amp;quot;, &amp;quot;XL&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;LX&amp;quot;, &amp;quot;LXX&amp;quot;, &amp;quot;LXXX&amp;quot;, &amp;quot;XC&amp;quot;};// 0 10 20 30 40 50 60 70 80 90
        string I[] = {&amp;quot;&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;II&amp;quot;, &amp;quot;III&amp;quot;, &amp;quot;IV&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;VI&amp;quot;, &amp;quot;VII&amp;quot;, &amp;quot;VIII&amp;quot;, &amp;quot;IX&amp;quot;};// 0 1 2 3 4 5 6 7 8 9

        return M[num / 1000] + C[num % 1000 / 100] + X[num % 100 / 10] + I[num % 10];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;罗马数字转换为数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int romanToInt(string s) {
        unordered_map&amp;lt;char, int&amp;gt; T = { { &#39;I&#39; , 1 },
                                    { &#39;V&#39; , 5 },
                                   { &#39;X&#39; , 10 },
                                   { &#39;L&#39; , 50 },
                                   { &#39;C&#39; , 100 },
                                   { &#39;D&#39; , 500 },
                                   { &#39;M&#39; , 1000 } };

        int sum = T[s.back()];
        for (int i = s.length() - 2; i &amp;gt;= 0; --i) 
        {
            // 根据罗马数字左减右加原则
            if (T[s[i]] &amp;lt; T[s[i + 1]])
            {
                sum -= T[s[i]];
            }
            else
            {
                sum += T[s[i]];
            }
        }

        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 461.Hamming Distance</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-461/</link>
      <pubDate>Fri, 24 Feb 2017 21:04:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-461/</guid>
      <description>&lt;p&gt;题目要求求出两个非负数之间二进制对应位不同值是多少，例如1对应二进制为 0 0 0 1（后四位），4对应二进制为 0 1 0 0，那么不同值就是2，从右往前看是第1位与第三位不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int hammingDistance(int x, int y) {
        int count = 0;
        // 最朴素的一种做法，就是每次求得两个数的最后一个比特位，然后比较，然后两个数右移
        while (x || y) { // 当x和y全部为0时才退出循环
            int a = x &amp;amp; 1; // 找到x和y二进制最后一位的数到底时0还是1
            int b = y &amp;amp; 1;
            if (a != b) ++count;
            x = x &amp;gt;&amp;gt; 1; // x右移一位
            y = y &amp;gt;&amp;gt; 1; // y右移一位
        }
        // 还有一种更简单的做法，就是将x^y的值求出来，求结果中有多少个1，那么就是答案
        // count = 0;
        // int n = x ^ y;
        // while (n) {
        //    ++count;
        //    n &amp;amp;= n - 1;
        // }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题7</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%987/</link>
      <pubDate>Wed, 15 Feb 2017 11:29:12 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%987/</guid>
      <description>&lt;p&gt;计算糖果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int main() {
    int a, b, c, d;
    int A, B, C;
    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;
    A = (a + c) / 2;
    B = A - a;
    C = B - b;
    if (A &amp;gt;= 0 &amp;amp;&amp;amp; B &amp;gt;= 0 &amp;amp;&amp;amp; C &amp;gt;=0 &amp;amp;&amp;amp; (A-B) == a &amp;amp;&amp;amp; (B-C) == b &amp;amp;&amp;amp; (A+B) == c &amp;amp;&amp;amp; (B+C) == d) cout &amp;lt;&amp;lt; A &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; B &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; C &amp;lt;&amp;lt; endl;
    else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题6</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</link>
      <pubDate>Wed, 15 Feb 2017 11:28:33 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</guid>
      <description>&lt;p&gt;买苹果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    if (n &amp;lt; 6 || n == 7) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    else {
        int n8 = n / 8, n6 ;

        if (n % 8 == 0) n6 = 0;
        else n6 = 1;

        while ( n8 * 8 + n6 * 6 &amp;gt; n) {
            --n8;
            ++n6;
        }

        if (n8 * 8 + n6 * 6 == n) cout &amp;lt;&amp;lt; n6 + n8 &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题5</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</link>
      <pubDate>Wed, 15 Feb 2017 11:18:02 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</guid>
      <description>&lt;p&gt;最大奇约数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
/*思路：
*如果是奇数，直接加上去就行了，如果是偶数，就需要一直除2把它变成奇数，如果直接一个
*一个的加，会超时，因此需要用到一些技巧
*例如，N = 10，那么我们此时一共有 1 2 3 4 5 6 7 8 9 10十个数，里面有10/2=5个奇数 1 3 5 7 9，那么奇数项的和为
*一个等差数列公式：s = n * a1 + (n * (n-1) / 2) * d,其中a1为第一项，n为个数，其实是N/2，d为2，那么我们套用进去
*s = N / 2 + (N / 2) * (N / 2 -1) / 2 * 2 = (N / 2) * (N / 2),又因为当N为奇数的时候，N / 2 == （N + 1） / 2
*所以不管是奇数偶数，都可以用 ((N+1) / 2) * ((N+1) / 2)这个公式求和
*这样我们每一次都把1~N的奇数项求和，剩下的是偶数项，继续 N= N/2 (因为 1 2 3 4 5 6 7 8 9 10将奇数项去掉后
*，还剩下 2 4 6 8 10，他们的最大奇约数其实就是 1 2 3 4 5的最大奇约数，所以求N/2的和就行了）求 1~N 的和，直到0
*/
int main() {
    long long N, sum = 0;
    cin &amp;gt;&amp;gt; N;
    for (long long i = N; i &amp;gt; 0; i /= 2) {
        sum += ((i+1) / 2) * ((i+1) / 2);
    }
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题4</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</link>
      <pubDate>Wed, 15 Feb 2017 11:00:24 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</guid>
      <description>&lt;p&gt;数字翻转：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

int rev(int num){
    vector&amp;lt;int&amp;gt; digit; 
    int t = 0; // 记录位数
    while (num) {
        digit.push_back(num % 10);
        num /= 10;
        ++t;
    }
    num = 0;
    for (int i = 0; i &amp;lt; t ; ++i) {
        num = num * 10 + digit[i];
    }
    return num;
}

int main() {
    int x, y;
    cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
    cout &amp;lt;&amp;lt; rev(rev(x) + rev(y)) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题3</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</link>
      <pubDate>Wed, 15 Feb 2017 10:53:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</guid>
      <description>&lt;p&gt;跳石板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

void find_yue_shu(int num, vector&amp;lt;int&amp;gt; &amp;amp;yue_shu) {
    for (int i = 2; i &amp;lt;= sqrt(num); ++i) {
        if (num % i == 0) {
            yue_shu.push_back(i);
            if (num / i != i) yue_shu.push_back(num / i);
        }
    }

}

int fuc(int N, int M) {
    if (N == M) return 0;
    vector&amp;lt;int&amp;gt; dp(M+1, -1);
    dp[N] = 0;
    for (int i = N; i &amp;lt;= M; ++i) {
        if (dp[i] == -1) continue; // 说明该点无法到达
        vector&amp;lt;int&amp;gt; yue_shu;
        find_yue_shu(i, yue_shu);
        for (int j = 0; j &amp;lt; yue_shu.size(); ++j) {
            int pos = yue_shu[j] + i; // 根据这个约数能到达的台阶位置
            if (pos &amp;lt;= M &amp;amp;&amp;amp; dp[pos] != -1) { // 这个位置小于M，并且该位置已经可以到达了，就要进行比较,否则直接+1
                dp[pos] = min(dp[pos] , dp[i] + 1);
            } else if (pos &amp;lt;= M) {
                dp[pos] = dp[i] + 1;
            }
        }
    }

    if (dp[M] == -1) return -1;
    return dp[M];
}

int main() {
    int N, M;
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;
    cout &amp;lt;&amp;lt; fuc(N, M) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题2</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</link>
      <pubDate>Wed, 15 Feb 2017 10:30:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</guid>
      <description>&lt;p&gt;优雅的点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int rr;
    cin &amp;gt;&amp;gt; rr;
    int r = (int)sqrt(rr);
    int sum = 0;

    for (int i = r; i &amp;gt;= 0; --i) {
        // 只计算第一象限的点
        int j = (int)sqrt(rr - i * i);
        if (i * i + j * j == rr) ++sum;
    }
    sum *= 4;
    // 如果半径本身就是整数点，那么相当于重复计算了四个轴的四个点，需要减去4
    if (r * r == rr) sum -= 4;
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题1</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:38 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981/</guid>
      <description>&lt;p&gt;牛课网上做的：
回文序列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;deque&amp;gt;
using namespace std;

bool is_hui_wen(deque&amp;lt;int&amp;gt; &amp;amp;dq) { // 判断是不是回文序列
    if (dq.empty()) return true;
    deque&amp;lt;int&amp;gt;::iterator beg = dq.begin();
    deque&amp;lt;int&amp;gt;::iterator en  = dq.end();
    --en;
    while ( beg &amp;lt; en) {
        if (*beg != *en) return false;
        ++beg;
        --en;
    }
    return true;
}

int min_change(deque&amp;lt;int&amp;gt; &amp;amp;dq) {
    int t = 0;
    while (!is_hui_wen(dq)) {// 如果不是，继续进行处理
        int b1 = *(dq.begin());
        dq.pop_front();
        int c1 = *(--dq.end());
        dq.pop_back();
        if (b1 == c1) continue; // 相等说明这个序列前后数字相同，略过，查看剩下的序列
        if (dq.empty() == false) { // 如果序列中还有其它元素
            if (b1 &amp;gt; c1) { // 前面的大，说明后面的需要两个数相加
                dq.push_front(b1);
                int c2 = *(--dq.end());
                c1 += c2;
                dq.pop_back();
                dq.push_back(c1);
            } else if (b1 &amp;lt; c1) { // 否则，前面的两个数相加
                dq.push_back(c1);
                int b2 = *(dq.begin());
                b1 += b2;
                dq.pop_front();
                dq.push_front(b1);
            }
        }
        ++t;
    }
    return t;
}

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    deque&amp;lt;int&amp;gt; dq; // 利用双向队列来做，比较方便
    for (int i = 0; i &amp;lt; n; ++i) {
        int num;
        cin &amp;gt;&amp;gt; num;
        dq.push_back(num);
    }
    cout &amp;lt;&amp;lt; min_change(dq) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 表达树构造</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-03/</link>
      <pubDate>Sun, 25 Dec 2016 16:47:22 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-03/</guid>
      <description>&lt;p&gt;看到这个题目就感觉和前两天做的“逆波兰表达式”很像，想的方法就是先将表达式转化成逆波兰表达式，因为逆波兰表达式就是后缀表达式，维护一个栈，从头开始遍历后缀表达式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;碰到数值，就生成个结点，然后将结点指针放入栈中&lt;/li&gt;
&lt;li&gt;碰到操作数，就在栈中弹出两个指针作为该操作数的右左子树，接着将指向操作数的指针入栈&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到最后栈中就只会剩下根节点了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition of ExpressionTreeNode:
 * class ExpressionTreeNode {
 * public:
 *     string symbol;
 *     ExpressionTreeNode *left, *right;
 *     ExpressionTreeNode(string symbol) {
 *         this-&amp;gt;symbol = symbol;
 *         this-&amp;gt;left = this-&amp;gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param expression: A string array
     * @return: The root of expression tree
     */
    ExpressionTreeNode* build(vector&amp;lt;string&amp;gt; &amp;amp;expression) {
        // write your code here
        // 首先将表达式转换为逆波兰表达式，也就是表达树的后缀表示形式
        vector&amp;lt;string&amp;gt; nibolan;
        stack&amp;lt;string&amp;gt; operat;
        operat.push(&amp;quot;@&amp;quot;);
        int i = 0;
        while ( i &amp;lt; expression.size()) {
            string s = expression[i];
            if (s != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;/&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;(&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;)&amp;quot;) {
                nibolan.push_back(s);

        } else if ( s == &amp;quot;(&amp;quot;) {
            operat.push(s);

        } else if ( s == &amp;quot;)&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.pop();
        } else if ( s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; (top == &amp;quot;*&amp;quot; || top == &amp;quot;/&amp;quot;) ) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s);
        } else {
           string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s); 
        }
        ++i;
    }
    string top = operat.top();
    while (top != &amp;quot;@&amp;quot; ) {
        nibolan.push_back(top);
        operat.pop();
        top = operat.top();
    }
    //从前往后，根据后缀表达式构建表达树,维护一个栈，栈中存放着树的指针，如果是操作符，就从栈中弹出两个指针作为它的右左子树，如果是数字，就直接入栈，最后栈中只会留下根指针
    stack&amp;lt;ExpressionTreeNode*&amp;gt; st;
    i = 0;
    while (i &amp;lt; nibolan.size()) {
        string s = nibolan[i];
        ExpressionTreeNode * node = new ExpressionTreeNode (s);
        if (s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot; || s == &amp;quot;+&amp;quot; || s == &amp;quot;-&amp;quot;) {
            ExpressionTreeNode* right = st.top();
            st.pop();
            ExpressionTreeNode* left = st.top();
            st.pop();
            node-&amp;gt;left = left;
            node-&amp;gt;right = right;
        }
        st.push(node);
        ++i;
    }
    if (st.empty()) return NULL;
    return st.top();

}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>