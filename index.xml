<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello world!</title>
    <link>https://shiweiHou.github.io/</link>
    <description>Recent content on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 31 Oct 2016 15:45:15 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>pcl 1.8.0 ALL in one &#43; vs 2013</title>
      <link>https://shiweihou.github.io/pointcloud/pcl/</link>
      <pubDate>Mon, 31 Oct 2016 15:45:15 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/pointcloud/pcl/</guid>
      <description>&lt;p&gt;最近需要做三维重建，要用到pcl函数库里带的 RegionGrowing 函数，官网上只有1.6.0的老版本安装包，而且貌似1.6.0版本里没有集成完全的 RegionGrowing 函数，遂找到1.8.0版本的PCL，进行处理。&lt;/p&gt;

&lt;p&gt;网上目前有很多根据源码利用Cmake来编译PCL的教程，后来在一个&lt;a href=&#34;http://unanancyowen.com/?p=2009&amp;amp;lang=en&#34;&gt;日本人的博客&lt;/a&gt;上找到PCL 1.8.0的 all-in-one，遂下载安装之。&lt;/p&gt;

&lt;p&gt;我的电脑是win10 64 + vs 2013， 于是下载的是PCL 1.8.0 All-in-one Installer MSVC2013 Win64 这个版本。&lt;/p&gt;

&lt;p&gt;安装过程：&lt;/p&gt;

&lt;p&gt;下载安装：下载并安装pcl_all_in_one 1.8.0,安装时选择“Add PCL to the system PATH for all users&amp;rdquo;选项，选择自己的安装路径，我是默认路径 C:\Program Files\PCL 1.8.0，然后一直点击下一步即可。注意在安装过程中会提示你安装OPENNI库，不要选择默认路径，要放在PCL路径下的3rdParty文件夹下，例如我的就安装在了 C:\Program Files\PCL 1.8.0\3rdParty\OpenNI2 这个文件夹内。&lt;/p&gt;

&lt;p&gt;配置环境变量：&lt;/p&gt;

&lt;p&gt;如果在上面的安装步骤中选择了“Add PCL to the system PATH for all users&amp;rdquo;选项，那么系统环境变量中会出现下图四个路径：如果没有的话可能就需要你手动添加了（一般出现这种情况的时候安装过程中就会提示“因为路径名太长无法写进去”之类的话） &lt;img src=&#34;https://raw.githubusercontent.com/shiweiHou/image/master/PCL-Install-image1.png&#34; alt=&#34;image1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后在系统变量Path中加入：&lt;img src=&#34;https://raw.githubusercontent.com/shiweiHou/image/master/PCL-Install-image2.png&#34; alt=&#34;image2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;设置包含目录：&lt;/p&gt;

&lt;p&gt;打开vs2013，新建win32控制台项目，选择X64平台，如果没有就新建个，然后在新建项目的属性管理器的中的VC++的包含目录中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Program Files\PCL 1.8.0\3rdParty\OpenNI2\Include\Win32;
C:\Program Files\PCL 1.8.0\3rdParty\Eigen\eigen3;
C:\Program Files\PCL 1.8.0\3rdParty\VTK\include\vtk-7.0;
C:\Program Files\PCL 1.8.0\3rdParty\FLANN\include\;
C:\Program Files\PCL 1.8.0\3rdParty\Qhull\include;
C:\Program Files\PCL 1.8.0\3rdParty\Boost\include\boost-1_61;
C:\Program Files\PCL 1.8.0\include\pcl-1.8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在VC++的库目录中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\Program Files\PCL 1.8.0\lib;
c:\Program Files\PCL 1.8.0\3rdParty\Qhull\lib;
c:\Program Files\PCL 1.8.0\3rdParty\FLANN\lib;
c:\Program Files\PCL 1.8.0\3rdParty\Boost\lib;
c:\Program Files\PCL 1.8.0\3rdParty\VTK\lib;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置附加依赖项：
DEBUG模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pcl_common_debug.lib
pcl_features_debug.lib
pcl_filters_debug.lib
pcl_io_debug.lib
pcl_io_ply_debug.lib
pcl_kdtree_debug.lib
pcl_keypoints_debug.lib
pcl_octree_debug.lib
pcl_outofcore_debug.lib
pcl_people_debug.lib
pcl_recognition_debug.lib
pcl_registration_debug.lib
pcl_sample_consensus_debug.lib
pcl_search_debug.lib
pcl_segmentation_debug.lib
pcl_surface_debug.lib
pcl_tracking_debug.lib
pcl_visualization_debug.lib
libboost_atomic-vc120-mt-gd-1_61.lib
libboost_chrono-vc120-mt-gd-1_61.lib
libboost_container-vc120-mt-gd-1_61.lib
libboost_context-vc120-mt-gd-1_61.lib
libboost_coroutine-vc120-mt-gd-1_61.lib
libboost_date_time-vc120-mt-gd-1_61.lib
libboost_exception-vc120-mt-gd-1_61.lib
libboost_filesystem-vc120-mt-gd-1_61.lib
libboost_graph-vc120-mt-gd-1_61.lib
libboost_iostreams-vc120-mt-gd-1_61.lib
libboost_locale-vc120-mt-gd-1_61.lib
libboost_log-vc120-mt-gd-1_61.lib
libboost_log_setup-vc120-mt-gd-1_61.lib
libboost_math_c99-vc120-mt-gd-1_61.lib
libboost_math_c99f-vc120-mt-gd-1_61.lib
libboost_math_c99l-vc120-mt-gd-1_61.lib
libboost_math_tr1-vc120-mt-gd-1_61.lib
libboost_math_tr1f-vc120-mt-gd-1_61.lib
libboost_math_tr1l-vc120-mt-gd-1_61.lib
libboost_mpi-vc120-mt-gd-1_61.lib
libboost_prg_exec_monitor-vc120-mt-gd-1_61.lib
libboost_program_options-vc120-mt-gd-1_61.lib
libboost_random-vc120-mt-gd-1_61.lib
libboost_regex-vc120-mt-gd-1_61.lib
libboost_serialization-vc120-mt-gd-1_61.lib
libboost_signals-vc120-mt-gd-1_61.lib
libboost_system-vc120-mt-gd-1_61.lib
libboost_test_exec_monitor-vc120-mt-gd-1_61.lib
libboost_thread-vc120-mt-gd-1_61.lib
libboost_timer-vc120-mt-gd-1_61.lib
libboost_type_erasure-vc120-mt-gd-1_61.lib
libboost_unit_test_framework-vc120-mt-gd-1_61.lib
libboost_wave-vc120-mt-gd-1_61.lib
libboost_wserialization-vc120-mt-gd-1_61.lib
flann_cpp_s-gd.lib
flann_s-gd.lib
flann-gd.lib
qhull_d.lib
qhull_p_d.lib
qhull_r_d.lib
qhullcpp_d.lib
qhullstatic_d.lib
qhullstatic_r_d.lib
vtkChartsCore-7.0-gd.lib
vtkCommonColor-7.0-gd.lib
vtkCommonComputationalGeometry-7.0-gd.lib
vtkCommonCore-7.0-gd.lib
vtkCommonDataModel-7.0-gd.lib
vtkCommonExecutionModel-7.0-gd.lib
vtkCommonMath-7.0-gd.lib
vtkCommonMisc-7.0-gd.lib
vtkCommonSystem-7.0-gd.lib
vtkCommonTransforms-7.0-gd.lib
vtkDICOMParser-7.0-gd.lib
vtkDomainsChemistry-7.0-gd.lib
vtkFiltersAMR-7.0-gd.lib
vtkFiltersCore-7.0-gd.lib
vtkFiltersExtraction-7.0-gd.lib
vtkFiltersFlowPaths-7.0-gd.lib
vtkFiltersGeneral-7.0-gd.lib
vtkFiltersGeneric-7.0-gd.lib
vtkFiltersGeometry-7.0-gd.lib
vtkFiltersHybrid-7.0-gd.lib
vtkFiltersHyperTree-7.0-gd.lib
vtkFiltersImaging-7.0-gd.lib
vtkFiltersModeling-7.0-gd.lib
vtkFiltersParallel-7.0-gd.lib
vtkFiltersParallelImaging-7.0-gd.lib
vtkFiltersProgrammable-7.0-gd.lib
vtkFiltersSMP-7.0-gd.lib
vtkFiltersSelection-7.0-gd.lib
vtkFiltersSources-7.0-gd.lib
vtkFiltersStatistics-7.0-gd.lib
vtkFiltersTexture-7.0-gd.lib
vtkFiltersVerdict-7.0-gd.lib
vtkGeovisCore-7.0-gd.lib
vtkIOAMR-7.0-gd.lib
vtkIOCore-7.0-gd.lib
vtkIOEnSight-7.0-gd.lib
vtkIOExodus-7.0-gd.lib
vtkIOExport-7.0-gd.lib
vtkIOGeometry-7.0-gd.lib
vtkIOImage-7.0-gd.lib
vtkIOImport-7.0-gd.lib
vtkIOInfovis-7.0-gd.lib
vtkIOLSDyna-7.0-gd.lib
vtkIOLegacy-7.0-gd.lib
vtkIOMINC-7.0-gd.lib
vtkIOMovie-7.0-gd.lib
vtkIONetCDF-7.0-gd.lib
vtkIOPLY-7.0-gd.lib
vtkIOParallel-7.0-gd.lib
vtkIOParallelXML-7.0-gd.lib
vtkIOSQL-7.0-gd.lib
vtkIOVideo-7.0-gd.lib
vtkIOXML-7.0-gd.lib
vtkIOXMLParser-7.0-gd.lib
vtkImagingColor-7.0-gd.lib
vtkImagingCore-7.0-gd.lib
vtkImagingFourier-7.0-gd.lib
vtkImagingGeneral-7.0-gd.lib
vtkImagingHybrid-7.0-gd.lib
vtkImagingMath-7.0-gd.lib
vtkImagingMorphological-7.0-gd.lib
vtkImagingSources-7.0-gd.lib
vtkImagingStatistics-7.0-gd.lib
vtkImagingStencil-7.0-gd.lib
vtkInfovisCore-7.0-gd.lib
vtkInfovisLayout-7.0-gd.lib
vtkInteractionImage-7.0-gd.lib
vtkInteractionStyle-7.0-gd.lib
vtkInteractionWidgets-7.0-gd.lib
vtkNetCDF-7.0-gd.lib
vtkNetCDF_cxx-7.0-gd.lib
vtkParallelCore-7.0-gd.lib
vtkRenderingAnnotation-7.0-gd.lib
vtkRenderingContext2D-7.0-gd.lib
vtkRenderingContextOpenGL-7.0-gd.lib
vtkRenderingCore-7.0-gd.lib
vtkRenderingFreeType-7.0-gd.lib
vtkRenderingGL2PS-7.0-gd.lib
vtkRenderingImage-7.0-gd.lib
vtkRenderingLIC-7.0-gd.lib
vtkRenderingLOD-7.0-gd.lib
vtkRenderingLabel-7.0-gd.lib
vtkRenderingOpenGL-7.0-gd.lib
vtkRenderingVolume-7.0-gd.lib
vtkRenderingVolumeOpenGL-7.0-gd.lib
vtkViewsContext2D-7.0-gd.lib
vtkViewsCore-7.0-gd.lib
vtkViewsInfovis-7.0-gd.lib
vtkalglib-7.0-gd.lib
vtkexoIIc-7.0-gd.lib
vtkexpat-7.0-gd.lib
vtkfreetype-7.0-gd.lib
vtkgl2ps-7.0-gd.lib
vtkhdf5-7.0-gd.lib
vtkhdf5_hl-7.0-gd.lib
vtkjpeg-7.0-gd.lib
vtkjsoncpp-7.0-gd.lib
vtklibxml2-7.0-gd.lib
vtkmetaio-7.0-gd.lib
vtkoggtheora-7.0-gd.lib
vtkpng-7.0-gd.lib
vtkproj4-7.0-gd.lib
vtksqlite-7.0-gd.lib
vtksys-7.0-gd.lib
vtktiff-7.0-gd.lib
vtkverdict-7.0-gd.lib
vtkzlib-7.0-gd.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RELEASE模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pcl_common_release.lib
pcl_features_release.lib
pcl_filters_release.lib
pcl_io_ply_release.lib
pcl_io_release.lib
pcl_kdtree_release.lib
pcl_keypoints_release.lib
pcl_octree_release.lib
pcl_outofcore_release.lib
pcl_people_release.lib
pcl_recognition_release.lib
pcl_registration_release.lib
pcl_sample_consensus_release.lib
pcl_search_release.lib
pcl_segmentation_release.lib
pcl_surface_release.lib
pcl_tracking_release.lib
pcl_visualization_release.lib
libboost_atomic-vc120-mt-1_61.lib
libboost_chrono-vc120-mt-1_61.lib
libboost_container-vc120-mt-1_61.lib
libboost_context-vc120-mt-1_61.lib
libboost_coroutine-vc120-mt-1_61.lib
libboost_date_time-vc120-mt-1_61.lib
libboost_exception-vc120-mt-1_61.lib
libboost_filesystem-vc120-mt-1_61.lib
libboost_graph-vc120-mt-1_61.lib
libboost_iostreams-vc120-mt-1_61.lib
libboost_locale-vc120-mt-1_61.lib
libboost_log-vc120-mt-1_61.lib
libboost_log_setup-vc120-mt-1_61.lib
libboost_math_c99-vc120-mt-1_61.lib
libboost_math_c99f-vc120-mt-1_61.lib
libboost_math_c99l-vc120-mt-1_61.lib
libboost_math_tr1-vc120-mt-1_61.lib
libboost_math_tr1f-vc120-mt-1_61.lib
libboost_math_tr1l-vc120-mt-1_61.lib
libboost_mpi-vc120-mt-1_61.lib
libboost_prg_exec_monitor-vc120-mt-1_61.lib
libboost_program_options-vc120-mt-1_61.lib
libboost_random-vc120-mt-1_61.lib
libboost_regex-vc120-mt-1_61.lib
libboost_serialization-vc120-mt-1_61.lib
libboost_signals-vc120-mt-1_61.lib
libboost_system-vc120-mt-1_61.lib
libboost_test_exec_monitor-vc120-mt-1_61.lib
libboost_thread-vc120-mt-1_61.lib
libboost_timer-vc120-mt-1_61.lib
libboost_type_erasure-vc120-mt-1_61.lib
libboost_unit_test_framework-vc120-mt-1_61.lib
libboost_wave-vc120-mt-1_61.lib
libboost_wserialization-vc120-mt-1_61.lib
flann_cpp_s.lib
flann_s.lib
flann.lib
qhull.lib
qhull_p.lib
qhull_r.lib
qhullcpp.lib
qhullstatic.lib
qhullstatic_r.lib
vtkChartsCore-7.0.lib
vtkCommonColor-7.0.lib
vtkCommonComputationalGeometry-7.0.lib
vtkCommonCore-7.0.lib
vtkCommonDataModel-7.0.lib
vtkCommonExecutionModel-7.0.lib
vtkCommonMath-7.0.lib
vtkCommonMisc-7.0.lib
vtkCommonSystem-7.0.lib
vtkCommonTransforms-7.0.lib
vtkDICOMParser-7.0.lib
vtkDomainsChemistry-7.0.lib
vtkFiltersAMR-7.0.lib
vtkFiltersCore-7.0.lib
vtkFiltersExtraction-7.0.lib
vtkFiltersFlowPaths-7.0.lib
vtkFiltersGeneral-7.0.lib
vtkFiltersGeneric-7.0.lib
vtkFiltersGeometry-7.0.lib
vtkFiltersHybrid-7.0.lib
vtkFiltersHyperTree-7.0.lib
vtkFiltersImaging-7.0.lib
vtkFiltersModeling-7.0.lib
vtkFiltersParallel-7.0.lib
vtkFiltersParallelImaging-7.0.lib
vtkFiltersProgrammable-7.0.lib
vtkFiltersSMP-7.0.lib
vtkFiltersSelection-7.0.lib
vtkFiltersSources-7.0.lib
vtkFiltersStatistics-7.0.lib
vtkFiltersTexture-7.0.lib
vtkFiltersVerdict-7.0.lib
vtkGeovisCore-7.0.lib
vtkIOAMR-7.0.lib
vtkIOCore-7.0.lib
vtkIOEnSight-7.0.lib
vtkIOExodus-7.0.lib
vtkIOExport-7.0.lib
vtkIOGeometry-7.0.lib
vtkIOImage-7.0.lib
vtkIOImport-7.0.lib
vtkIOInfovis-7.0.lib
vtkIOLSDyna-7.0.lib
vtkIOLegacy-7.0.lib
vtkIOMINC-7.0.lib
vtkIOMovie-7.0.lib
vtkIONetCDF-7.0.lib
vtkIOPLY-7.0.lib
vtkIOParallel-7.0.lib
vtkIOParallelXML-7.0.lib
vtkIOSQL-7.0.lib
vtkIOVideo-7.0.lib
vtkIOXML-7.0.lib
vtkIOXMLParser-7.0.lib
vtkImagingColor-7.0.lib
vtkImagingCore-7.0.lib
vtkImagingFourier-7.0.lib
vtkImagingGeneral-7.0.lib
vtkImagingHybrid-7.0.lib
vtkImagingMath-7.0.lib
vtkImagingMorphological-7.0.lib
vtkImagingSources-7.0.lib
vtkImagingStatistics-7.0.lib
vtkImagingStencil-7.0.lib
vtkInfovisCore-7.0.lib
vtkInfovisLayout-7.0.lib
vtkInteractionImage-7.0.lib
vtkInteractionStyle-7.0.lib
vtkInteractionWidgets-7.0.lib
vtkNetCDF-7.0.lib
vtkNetCDF_cxx-7.0.lib
vtkParallelCore-7.0.lib
vtkRenderingAnnotation-7.0.lib
vtkRenderingContext2D-7.0.lib
vtkRenderingContextOpenGL-7.0.lib
vtkRenderingCore-7.0.lib
vtkRenderingFreeType-7.0.lib
vtkRenderingGL2PS-7.0.lib
vtkRenderingImage-7.0.lib
vtkRenderingLIC-7.0.lib
vtkRenderingLOD-7.0.lib
vtkRenderingLabel-7.0.lib
vtkRenderingOpenGL-7.0.lib
vtkRenderingVolume-7.0.lib
vtkRenderingVolumeOpenGL-7.0.lib
vtkViewsContext2D-7.0.lib
vtkViewsCore-7.0.lib
vtkViewsInfovis-7.0.lib
vtkalglib-7.0.lib
vtkexoIIc-7.0.lib
vtkexpat-7.0.lib
vtkfreetype-7.0.lib
vtkgl2ps-7.0.lib
vtkhdf5-7.0.lib
vtkhdf5_hl-7.0.lib
vtkjpeg-7.0.lib
vtkjsoncpp-7.0.lib
vtklibxml2-7.0.lib
vtkmetaio-7.0.lib
vtkoggtheora-7.0.lib
vtkpng-7.0.lib
vtkproj4-7.0.lib
vtksqlite-7.0.lib
vtksys-7.0.lib
vtktiff-7.0.lib
vtkverdict-7.0.lib
vtkzlib-7.0.lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在安装pcl 1.8.0 all-in-one和配置好环境变量之后，需重启下计算机，再进入vs配置&lt;/li&gt;
&lt;li&gt;注意OPENNI的安装路径不要搞错了&lt;/li&gt;
&lt;li&gt;PCL 1.8.0在vs中会有个问题，就是运行的时候会提示：&lt;code&gt;error C4996: &#39;pcl::SAC_SAMPLE_SIZE&#39;: This map is deprecated and is kept only to prevent breaking existing user code. Starting from PCL 1.8.0 model sample size is a protected member of the SampleConsensusModel class&lt;/code&gt;，这个是1.8.0的小毛病，解决方法是：打开项目属性页 -&amp;gt; C/C++ -&amp;gt; 常规 -&amp;gt; SDL检查(设置为否)。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>线性回归</title>
      <link>https://shiweihou.github.io/machinelearning/ex1/</link>
      <pubDate>Sun, 30 Oct 2016 16:10:31 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/machinelearning/ex1/</guid>
      <description>

&lt;p&gt;从今天开始，开始记录学习机器学习学习过程。目前的学习方法是根据&lt;a href=&#34;https://www.coursera.org/learn/machine-learning&#34;&gt;Coursera&lt;/a&gt;上Andrew Ng大牛的机器学习课程，据说是同名的斯坦福大学公开课的简化版本，仅介绍基本原理及提供配套的练习，非常适合新手入门。强烈推荐大家去看下视频，讲解的很详细，而且还有配套的演示过程，非常适合新手。&lt;/p&gt;

&lt;p&gt;有关线性回归的具体内容我就不多说了，网上例子有很多，教程有很多，我只谈下在学习过程中自己遇到的一些问题及看法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在学习过程中，参数需要同时更新，不能用更新好的参数去更新下一个参数，例如不能用更新好的 theta0 去更新 theta1.&lt;/li&gt;
&lt;li&gt;如果数据特征变化尺度过大，例如x1在[1,10]范围内，而x2就在[10000,10000000]范围内，就需要进行特征缩放，重新缩放特征的范围到[0, 1]或[-1, 1]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;顺便贴下第一课的课后作业的答案：&lt;/p&gt;

&lt;h2 id=&#34;computecost-m&#34;&gt;computeCost.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function J = computeCost(X, y, theta)
%COMPUTECOST Compute cost for linear regression
%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the
%   parameter for linear regression to fit the data points in X and y
% Initialize some useful values
m = length(y); % number of training examples
% You need to return the following variables correctly 
J = 0;
% ====================== YOUR CODE HERE ======================
% Instructions: Compute the cost of a particular choice of theta
%               You should set J to the cost.
for i = 1 : m,
J = J + (theta(1) * X(i,1) + theta(2) * X(i,2) - y(i)) ^ 2;
end
J = J / (2 * m);
% =========================================================================
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;computecostmulti-m&#34;&gt;computeCostMulti.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function J = computeCostMulti(X, y, theta)
%COMPUTECOSTMULTI Compute cost for linear regression with multiple variables
%   J = COMPUTECOSTMULTI(X, y, theta) computes the cost of using theta as the
%   parameter for linear regression to fit the data points in X and y
% Initialize some useful values
m = length(y); % number of training examples
% You need to return the following variables correctly 
J = 0;
% ====================== YOUR CODE HERE ======================
% Instructions: Compute the cost of a particular choice of theta
%               You should set J to the cost.
for i = 1 : m 
    JJ = 0;
    for j = 1 : size(theta,1)
        JJ = JJ + theta(j) * X(i,j);
    end
    JJ = JJ - y(i);
    J = J + JJ ^ 2;
end
J = J / (2 * m);
% =========================================================================
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;featurenormalize-m&#34;&gt;featureNormalize.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [X_norm, mu, sigma] = featureNormalize(X)
%FEATURENORMALIZE Normalizes the features in X 
%   FEATURENORMALIZE(X) returns a normalized version of X where
%   the mean value of each feature is 0 and the standard deviation
%   is 1. This is often a good preprocessing step to do when
%   working with learning algorithms.
% You need to set these values correctly
X_norm = X;
mu = zeros(1, size(X, 2));
sigma = zeros(1, size(X, 2));
% ====================== YOUR CODE HERE ======================
% Instructions: First, for each feature dimension, compute the mean
%               of the feature and subtract it from the dataset,
%               storing the mean value in mu. Next, compute the 
%               standard deviation of each feature and divide
%               each feature by it&#39;s standard deviation, storing
%               the standard deviation in sigma. 
%
%               Note that X is a matrix where each column is a 
%               feature and each row is an example. You need 
%               to perform the normalization separately for 
%               each feature. 
%
% Hint: You might find the &#39;mean&#39; and &#39;std&#39; functions useful.
%       
avg = mean(X);
piancha = std(X);
for row = 1 : size(X,1)
    for col = 1 : size(X,2)
        X_norm(row,col) = (X(row,col) - avg(col)) / piancha(col);
    end
end
mu = avg;
sigma = piancha;
% ============================================================
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gradientdescent-m&#34;&gt;gradientDescent.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)
%GRADIENTDESCENT Performs gradient descent to learn theta
%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by 
%   taking num_iters gradient steps with learning rate alpha

% Initialize some useful values
m = length(y); % number of training examples
J_history = zeros(num_iters, 1);

for iter = 1:num_iters
% ====================== YOUR CODE HERE ======================
% Instructions: Perform a single gradient step on the parameter vector
%               theta. 
%
% Hint: While debugging, it can be useful to print out the values
%       of the cost function (computeCost) and gradient here.
%
% ============================================================
% Save the cost J in every iteration    
    J_history(iter) = computeCost(X, y, theta);
    theta1 = theta;
    for j = 1:2
    J = 0;
    for i = 1 : m
        J = J + (theta(1) * X(i,1) + theta(2) * X(i,2) - y(i)) * X(i,j);
    end
    theta1(j) = theta(j) - alpha * J / m;
    end
    theta = theta1;
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gradientdescentmulti-m&#34;&gt;gradientDescentMulti.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)
%GRADIENTDESCENT Performs gradient descent to learn theta
%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by 
%   taking num_iters gradient steps with learning rate alpha

% Initialize some useful values
m = length(y); % number of training examples
J_history = zeros(num_iters, 1);

for iter = 1:num_iters
% ====================== YOUR CODE HERE ======================
% Instructions: Perform a single gradient step on the parameter vector
%               theta. 
%
% Hint: While debugging, it can be useful to print out the values
%       of the cost function (computeCost) and gradient here.
%
% ============================================================
% Save the cost J in every iteration    
    J_history(iter) = computeCost(X, y, theta);
    theta1 = theta;
    for j = 1:2
    J = 0;
    for i = 1 : m
        J = J + (theta(1) * X(i,1) + theta(2) * X(i,2) - y(i)) * X(i,j);
    end
    theta1(j) = theta(j) - alpha * J / m;
    end
    theta = theta1;
end

end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 二进制表示</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-13-02/</link>
      <pubDate>Thu, 13 Oct 2016 20:46:54 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-13-02/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/binary-representation/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说是困难题，其实很简单的，就是将字符串中整数部分和小数部分分别提取出来，然后根据整数化二进制和小数划二进制的形式来求。唯一有问题的就是字符串中的小数部分化成小数时，如果按照传统的一个个来做的话，在计算机中表示很奇怪，例如对于&lt;code&gt;4096.6435546875&lt;/code&gt;，小数部分按照6*10（-1） + 4*10（-2）&amp;hellip;这样求的话，在计算机中实际表示为&lt;code&gt;0.64355468750000011&lt;/code&gt;，所以很奇怪，估计是和计算机中浮点型的存储方式有关，所以后来就直接用C++自带的库函数&lt;code&gt;atof()&lt;/code&gt;函数来转换，这样就ok了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 *@param n: Given a decimal number that is passed in as a string
 *@return: A string
 */
string binaryRepresentation(string n) {
    // wirte your code here
    string ret;
    if (n.empty()) return 0;
    int len = n.size();
    int i = 0;
    while (i &amp;lt; len &amp;amp;&amp;amp; n[i] != &#39;.&#39;) ++i;
    int j = 0;
    bool flag = true;
    if (n[0] == &#39;-&#39;) {
        flag = false;
        ++j;
        ret += &amp;quot;1&amp;quot;;
    }

    long number = 0;
    while (j &amp;lt; i) {
        number = number * 10 + (n[j] - &#39;0&#39;);
        ++j;
    }
    longToBinary(number, ret);

    if (i == len) return ret;
    ret += &amp;quot;.&amp;quot;;


    double number1 = 0.0;
    ++i;
    int count = -1;
    while (i &amp;lt; len) {
        number1 += (n[i] - &#39;0&#39;) * (double)pow(10, count);
        ++i;
        --count;
    }

    bool yes = true;
    // 自己计算的不行，还得靠库函数
    double decPart = atof(n.substr(n.find(&amp;quot;.&amp;quot;), n.size() - n.find(&amp;quot;.&amp;quot;)).c_str());
    number1 = decPart;
    yes = digitToBinary(number1, ret);

    int len1 = ret.size();
    if (ret[len1-1] == &#39;.&#39;) ret = ret.substr(0,len1-1);
    if (yes) return ret;
    ret = &amp;quot;ERROR&amp;quot;;
    return ret;
}

bool digitToBinary(double number, string &amp;amp;s) {
    int time = 0;
    double number1 = 1.0;
    double number2 = 0.0;
    while (time &amp;lt;= 32) {
        if (number == number1) 
            break;
        if (number == number2) 
            break;
        number *= 2;
        if (number &amp;gt;= 1) {
            number -= 1.0;
            s += to_string(1);
        } else s += to_string(0);

        ++time;
    }

    if (time &amp;lt;= 32) return true;
    return false;
}
void longToBinary(long number, string &amp;amp;s) {
    vector&amp;lt;int&amp;gt; vb;
    while (number != 0) {
        vb.push_back(number % 2) ;
        number /= 2;
    }
    if (vb.empty()) {
        s += to_string(0);
        return;
    }
    reverse(vb.begin(), vb.end());
    for (auto e : vb) {
        s += to_string(e);
    }

    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> LintCode 逆波兰表达式求值</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-13-01/</link>
      <pubDate>Thu, 13 Oct 2016 20:43:48 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-13-01/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/evaluate-reverse-polish-notation/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;题意很明确，其实就是四则运算的后缀求值，用栈来维护，中间过程中没有考虑栈元素不够或者除数为0的情况，但也AC了，说明输入的数据比较严格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) {
    // Write your code here
    stack&amp;lt;int&amp;gt; s;
    int ans;
    if (tokens.empty()) return ans;
    for (auto e : tokens) {
        if (e != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;/&amp;quot;) {
            int number = stoi(e);
            s.push(number);
            continue;
        } 
        int x = s.top();
        s.pop();
        int y = s.top();
        s.pop();
        if (e == &amp;quot;+&amp;quot;) s.push(x + y);
        if (e == &amp;quot;-&amp;quot;) s.push(y - x);
        if (e == &amp;quot;/&amp;quot;) s.push(y / x);
        if (e == &amp;quot;*&amp;quot;) s.push(x * y);
    }

    return s.top();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 买卖股票的最佳时机（1 2 3 4）</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-11-01/</link>
      <pubDate>Tue, 11 Oct 2016 20:21:15 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-11-01/</guid>
      <description>

&lt;h2 id=&#34;买卖股票的最佳时机-1-1&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock/&#34;&gt;买卖股票的最佳时机&lt;/a&gt; 1&lt;/h2&gt;

&lt;p&gt;题目就不贴了，链接在上面&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;题意很简单，因为我们最多只可以完成一次交易，而且股票交易必须在前面买入才可以卖出，所以我们只需要从前往后遍历，维护两个变量值，minPrice表示所有的股票中价钱最低的那个，maxProfit表示到第i天所能获得的最大利润。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if (prices.empty()) return 0;

    int n = prices.size();Lint
    int minPrice = prices[0];
    int maxProfit = 0;

    for (int i = 1; i &amp;lt; n; ++i) {
    // 如果当前股票价格还要小于前面的已知的最低价格，就替换之，当然不需要进行卖出，相反还要买入
        if (minPrice &amp;gt; prices[i]) {
            minPrice = prices[i];
        } else  // 否则的话，在第i天使可以尝试卖出的，更新maxProfit
            maxProfit = max(maxProfit, prices[i] - minPrice);
    }

    return maxProfit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-ii-2&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-ii/&#34;&gt;买卖股票的最佳时机 II&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;最笨的一种方法。因为要尽可能的获得最大利润，当然是完成每次交易的获得的利润越大越好。因为我没有想到当天卖出再买入这件事，只是想到一天只能买入或者卖出，所以得到如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int sum = 0;
    if (prices.empty() || prices.size() &amp;lt; 2) return sum;

    int n = prices.size();

    int i = 1;
    // buy 记录买入股票的价钱
    int buy = prices[0];
    while ( i &amp;lt; n ) {
    // 如果当天的价格还在上涨，那就不卖出，继续往下看；如果不是，说明从buy的那一天到i-1天都是上涨的，那么就在第i-1天卖出，继续往下看。
        if (prices[i] &amp;gt; prices[i-1]) {
            ++i;
            if (i == n) sum += prices[i-1] - buy;
        }
        else {
            sum += prices[i-1] - buy;
            buy = prices[i];
            ++i;
        }
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网上还有一种更简单的算法，就是尽可能交易更多的次数，当天可以买也可以卖，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int sum = 0;
    if (prices.empty() || prices.size() &amp;lt; 2) return sum;

    int n = prices.size();
    for (int i = 1; i &amp;lt; n; ++i) {
    // 意思是只要当天卖可以有利润，就卖出去，再买回来，继续往后看
        if (prices[i] &amp;gt; prices[i-1])
            sum += prices[i] - prices[i-1];
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-iii-3&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-iii/&#34;&gt;买卖股票的最佳时机 III&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;因为是可以完成两笔交易，所以最最容易想到的办法就是对每个时间点i，分别计算1~i 和 i~n 所能获得的最大利润和。但这样时间复杂度为 O(n^2)。但是我们知道我们在计算1~i的最大利润的时候，1~i-1的利润已经计算过了，不需要再重新计算一遍，因此：&lt;strong&gt;保存两个数组，left[i], right[i],分别记录从左到右和从右往左分别到i位置所能产生的最大利润，最后直接遍历一遍两个数组就可以了，找出最大的left[i] + right[i] 组合，该解法实际上就是将 1 的解法双向各执行一遍记录结果&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;

    vector&amp;lt;int&amp;gt; left (prices.size(), 0);
    vector&amp;lt;int&amp;gt; right (prices.size(), 0);

    int leftMin = prices[0];
    int rightMax = prices[prices.size()-1];

    int sum = 0;
    //计算左半段最大收益
    for(int i = 1 ; i &amp;lt; prices.size(); ++i){
        leftMin = min(prices[i], leftMin);
        left[i] = max(prices[i] - leftMin, left[i-1]);
    }
    //计算右半段最大收益
    for(int i = prices.size() - 2 ; i &amp;gt;= 0; --i){
        rightMax = max(prices[i], rightMax);
        right[i] = max(rightMax - prices[i], right[i+1]);
    }
    //找出两次交易最大收益组合
    for(int i = 0 ; i &amp;lt; prices.size(); ++i){
        if( (left[i]+right[i]) &amp;gt; sum ) 
            sum = left[i] + right[i];
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在网上还看到一种解法，十分巧妙：其实我们并不需要知道每个时间点买卖第一第二笔股票收益的全部信息，我们只要知道前一个时间点买卖第一第二笔股票的最大收益信息，就可以直到当前最大的收益信息了，这样可以为我们省去额外空间。这里我们遍历prices数组的时候，维护四个变量:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;release2是在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;hold2是在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;release1是在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;hold1是在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里计算顺序按照release2 -&amp;gt; hold2 -&amp;gt; release1 -&amp;gt; hold1，因为卖是要后于买的，而第二次交易也是后于第一次交易的，通过这个顺序我们能用这些变量自身来记录上次的值。相当于release2的时间点要先于hold1四个点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int hold1 = INT_MIN, hold2 = INT_MIN;
    int release1 = 0, release2 = 0;
    int n = prices.size();
    for(int i = 0; i &amp;lt; n; ++i){
        // 在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱
        // 或者上一轮卖出第二笔股票后手里剩的钱两者中较大的
        release2 = max(release2, hold2 + prices[i]);
        // 在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱
        // 或者上一轮买入第二笔股票后手里剩的钱两者中较大的
        hold2 = max(hold2, release1 - prices[i]);
        // 在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱
        // 或者上一轮卖出第一笔股票后手里剩的钱两者中较大的
        release1 = max(release1, hold1 + prices[i]);
        // 在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱
        // 或者初始资金（不买）中较大的
        hold1 = max(hold1, 0 - prices[i]);
    }
    return release2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-iv-4&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-iv/&#34;&gt;买卖股票的最佳时机 IV&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;我们将第 i 天已经执行 j 笔交易的最大收益作为全局变量 global[i][j], 将第 i 天正好完成第 j 笔交易的最大收益作为局部变量 local[i][j].&lt;/p&gt;

&lt;p&gt;也就是说， global[i][j] 就是我们最终要得到的结果，但 local[i][j] 的意思是，再第i天必须当天完成第j笔交易，而 global[i][j] 则不需要。&lt;/p&gt;

&lt;p&gt;对于 global[i][j], 也就是我们要知道的第i天已经完成j笔交易获得的最大收益，可以基于第 i-1 天完成 j 笔交易的最大收益与 第 i 天正好完成第 j 笔交易的最大收益，即 global[i][j] = max ( global[i-1][j], local[i][j] ).&lt;/p&gt;

&lt;p&gt;对于 local[i][j], 也就是我们要求的第i天刚好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值， 还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。 要注意的是，&lt;/p&gt;

&lt;p&gt;第i-1天正好完成第j-1笔交易的这种情况，当前交易的差值去0和实际昨天今天差价中较大的那个，因为如果我们还剩下1次交易机会，如果prices[i] &amp;gt; prices[i-1],我们完全可以在第i-1天完成第j-1笔交易后，再当天买入，第i天卖出。&lt;/p&gt;

&lt;p&gt;但是对于第i-1天正好完成第j笔交易这种情况，因为第i-1天正好完成第j笔交易，那么第i天的交易其实在第i-1天交易里面，也就是第i天要连着第i-1天交易，使得第i-1天完成的第j笔交易正好和第i天完成的第j笔交易是同一天交易，所以无论prices[i]是否大于prices[i-1], 这次交易都要进行下去，所以local[i][j] = max ( global[i-1][j-1] + max (diff, 0), local[i-1][j] + diff);diff = prices[i] - prices[i-1].&lt;/p&gt;

&lt;p&gt;PS:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于k &amp;gt; n /
2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &amp;gt; n / 2，就相当于无限次交易。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方法理解了很简单，但真要自己写出来很难。我也没有写出来，还是参考的别人的答案才做出来，还需努力啊。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(int k, vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;
    //用II的解法优化k &amp;gt; n / 2的情况
    int n = prices.size();
    if(k &amp;gt; n / 2){
        int sum = 0;
        for(int i = 1; i &amp;lt; n; ++i){
            if(prices[i] &amp;gt; prices[i-1]) sum += prices[i] - prices[i-1];
        }
        return sum;
    }
    //初始化全局变量和局部变量
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; local(n+1, vector&amp;lt;int&amp;gt;(k+1, 0));
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; global(n+1, vector&amp;lt;int&amp;gt;(k+1, 0));

    for(int i = 1; i &amp;lt; n; ++i){
        int diff = prices[i] - prices[i-1];
        for(int j = 1; j &amp;lt; k + 1; ++j){
            //更新局部变量
            local[i][j] = max(global[i-1][j-1] + max(0, diff), local[i-1][j] + diff);
            //更新全局变量
            global[i][j] = max(global[i-1][j], local[i][j]);
        }
    }
    return global[n - 1][k];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种解法，类似于 ||| 中后一种解法一样，区别是我们这次要用 2K 个变量来记录 K 次交易。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(int k, vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;
    //用II的解法优化k &amp;gt; n / 2的情况
    int n = prices.size();

    if(k &amp;gt; n / 2){
        int sum = 0;
        for(int i = 1; i &amp;lt; n; ++i){
            if(prices[i] &amp;gt; prices[i-1]) sum += prices[i] - prices[i-1];
        }
        return sum;
    }
    //初始化买卖股票后剩余金钱的数组
    vector&amp;lt;int&amp;gt; release (k + 1, 0);
    vector&amp;lt;int&amp;gt; hold    (k + 1, INT_MIN);


    for(int i = 0; i &amp;lt; n; i++){
        for(int j = 1; j &amp;lt; k+1; ++j){
            //卖出第j笔交易，所剩余的钱
            release[j] = max(release[j], hold[j] + prices[i]);
            //买入第j笔交易，所剩余的钱
            hold[j] = max(hold[j], release[j-1] - prices[i]);
        }
    }
    return release[k];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 克隆二叉树</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-09-02/</link>
      <pubDate>Sun, 09 Oct 2016 20:57:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-09-02/</guid>
      <description>&lt;p&gt;题目链接：&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/clone-binary-tree/&#34;&gt;LintCode 克隆二叉树&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;很简单，就是在对二叉树进行遍历的时候重新生成节点就可以了，前序、中序或者后序遍历都可以，我用的是前序遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Definition of TreeNode:
* class TreeNode {
* public:
*     int val;
*     TreeNode *left, *right;
*     TreeNode(int val) {
*         this-&amp;gt;val = val;
*         this-&amp;gt;left = this-&amp;gt;right = NULL;
*     }
* }
*/
class Solution {
public:
/**
 * @param root: The root of binary tree
 * @return root of new tree
 */
TreeNode* cloneTree(TreeNode *root) {
    // Write your code here
    if (root == NULL) return NULL;
    TreeNode *newRoot = new TreeNode(root-&amp;gt;val);
    if (root-&amp;gt;left) newRoot-&amp;gt;left = cloneTree(root-&amp;gt;left);
    if (root-&amp;gt;right) newRoot-&amp;gt;right = cloneTree(root-&amp;gt;right);
    return newRoot;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 平面列表</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-09-01/</link>
      <pubDate>Sun, 09 Oct 2016 20:43:08 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-09-01/</guid>
      <description>&lt;p&gt;不贴题目描述了，链接在这：&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/flatten-list/&#34;&gt;LintCode 平面列表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因为这个用递归就特别好做，只要一直递归层次就行，知道为空或者找到数字。递归的代码就不写了，很简单。题目希望我们可以用非递归的方法，一般像这种嵌套的查找，都可以用栈来实现，注意栈内元素是先进后出的，也就是说出来的元素顺序和原始列表中是相反的，因此需要做一次反转操作，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
// @param nestedList a list of NestedInteger
// @return a list of integer
vector&amp;lt;int&amp;gt; flatten(vector&amp;lt;NestedInteger&amp;gt; &amp;amp;nestedList) {
    // Write your code here
    vector&amp;lt;int&amp;gt; ret;
    vector&amp;lt;int&amp;gt; tmpans;
    if (nestedList.empty()) return ret;
    int n = nestedList.size();
    for (int i = 0; i &amp;lt; n; ++i) {
        if (nestedList[i].isInteger()) ret.push_back(nestedList[i].getInteger());
        else {
            tmpans.clear();
            NestedInteger tmp = nestedList[i];
            stack&amp;lt;NestedInteger&amp;gt; st;
            st.push(tmp);
            while (st.empty() == false) {
                tmp = st.top();
                st.pop();
                if (tmp.isInteger()) tmpans.push_back(tmp.getInteger());
                else {
                    vector&amp;lt;NestedInteger&amp;gt; vn = tmp.getList();
                    for (int i = 0; i &amp;lt; vn.size(); ++i) st.push(vn[i]);
                }
            }
            if (tmpans.empty() == false) {
                reverse(tmpans.begin(), tmpans.end());
                for (int i = 0; i &amp;lt; tmpans.size(); ++i) ret.push_back(tmpans[i]);
            }
        }
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很惊讶的是，我想用栈可以做，那我用队列也可以啊，而且队列是先进先出的，元素顺序是不变的，多好？然而结果出来大吃一惊，发现是有问题，同一个列表元素相对顺序没问题，但整体顺序出现了问题，用队列的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
// @param nestedList a list of NestedInteger
// @return a list of integer
vector&amp;lt;int&amp;gt; flatten(vector&amp;lt;NestedInteger&amp;gt; &amp;amp;nestedList) {
    // Write your code here
    vector&amp;lt;int&amp;gt; ret;
    vector&amp;lt;int&amp;gt; tmpans;
    if (nestedList.empty()) return ret;
    int n = nestedList.size();
    for (int i = 0; i &amp;lt; n; ++i) {
        if (nestedList[i].isInteger()) ret.push_back(nestedList[i].getInteger());
        else {
            tmpans.clear();
            NestedInteger tmp = nestedList[i];
            queue&amp;lt;NestedInteger&amp;gt; qt;
            qt.push(tmp);
            while (qt.empty() == false) {
                tmp = qt.front();
                qt.pop();
                if (tmp.isInteger()) ret.push_back(tmp.getInteger());
                else {
                    vector&amp;lt;NestedInteger&amp;gt; vn = tmp.getList();
                    for (int i = 0; i &amp;lt; vn.size(); ++i) qt.push(vn[i]);
                }
            }
        }
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如对于输入数据&lt;code&gt;[[1,1],2,[1,1]]&lt;/code&gt;,我得到的结果是&lt;code&gt;[2,1,1,1,1]&lt;/code&gt;,本来应该是&lt;code&gt;[1,1,2,1,1]&lt;/code&gt;,但是我用其它数据测试的时候，例如&lt;code&gt;[1,2,[1,1]]&lt;/code&gt;,我的结果和答案是一致的，再比如&lt;code&gt;[[1,2],3,[1,1]]&lt;/code&gt;,我的答案是&lt;code&gt;[3,1,2,1,1]&lt;/code&gt;,而正确答案为&lt;code&gt;[1,2,3,1,1]&lt;/code&gt;,好像就是如果第一个元素是列表的话，就会出错，我没有想明白为什么。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 和大于S的最小子数组</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-07-02/</link>
      <pubDate>Fri, 07 Oct 2016 20:41:56 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-07-02/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;p&gt;给定一个由 n 个整数组成的数组和一个正整数 s ，请找出该数组中满足其和 ≥ s 的最小长度子数组。如果无解，则返回 -1。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定数组 [2,3,1,2,4,3] 和 s = 7, 子数组 [4,3] 是该条件下的最小长度子数组。&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;LintCode上面挑战是O(n)时间复杂度，我想O（n*n）不知道可不可以过，于是就试了下，发现还是不行，73%的test通过。对于一个数组，然后要求O（n）时间复杂度的，一般都是通过两根指针，要么一个从头向尾和一个从尾向头，要么一个快指针，一个慢指针。我一开始用第一种方法，后来写出来发现还是O（n*n)的时间复杂度，于是改用快慢指针。因为s是正整数，所以我们可以不考虑负数的情况，利用快慢指针来求答案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int minimumSize(vector&amp;lt;int&amp;gt; &amp;amp;nums, int s) {
    // write your code here
    if (nums.empty()) return -1;

    int n = nums.size();
    int sum = 0;
    int minLength = n + 1;
    int fast = 0;
    int slow = 0;

    while (fast &amp;lt; n) {
        while (fast &amp;lt; n &amp;amp;&amp;amp; sum &amp;lt; s) { //首先找到从slow开始一直和大于s的fast为止
            sum += nums[fast];
            ++fast;
        }           //退出循环后，fast指向第一次和大于s的后面那个位置，即区间为[slow, fast)
        if (sum &amp;gt;= s &amp;amp;&amp;amp; minLength &amp;gt; fast - slow) minLength = fast - slow ;
        while (sum &amp;gt;= s) {
            if (sum &amp;gt;= s &amp;amp;&amp;amp; minLength &amp;gt; fast - slow ) minLength = fast - slow;
            sum -= nums[slow];  // 开始增加slow，减去前面的值，因为要求是连续的，所以直接减去即可
            ++slow;

        }
    }

    if (minLength == n + 1) return -1;
    return minLength;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 和为零的子矩阵</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-07-01/</link>
      <pubDate>Fri, 07 Oct 2016 18:37:40 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-07-01/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;p&gt;给定一个整数矩阵，请找出一个子矩阵，使得其数字之和等于0.输出答案时，请返回左上数字和右下数字的坐标。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定矩阵&lt;code&gt;[[1, 5, 7],[3, 7, 8],[4, -8, 9],]&lt;/code&gt;, 返回&lt;code&gt;[(1,1), (2,2)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始是想着暴搜看看能不能过，发现果然不能，只过了82%的test，还是可以的了~~~&lt;/p&gt;

&lt;p&gt;后来就想了个思路，既然是求和为0的矩阵，那么必然存在有两个矩阵一大一小，大小矩阵和是相等的，那么大矩阵和小矩阵的差别的那一块矩阵，就是和为0的矩阵。所以我们只要找到那两个矩阵和相等的一大一小的矩阵就可以了。其差值就是要求的答案。&lt;/p&gt;

&lt;p&gt;求矩阵和的时候是有个递推公式的，对于位于（i，j）处的矩阵和，其递推公式为 sum[i][j] = sum[i-1][j] + sum[i][j-1] + matrix[i][j],大家画一下图，很简单就出来了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; submatrixSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) {
    // Write your code here
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ret;
    if (matrix.empty()) return ret;
    ret.resize(2);
    ret[0].resize(2);
    ret[1].resize(2);

    int row = matrix.size();
    int col = matrix[0].size();

    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; sum(row+1, vector&amp;lt;int&amp;gt;(col+1, 0));

    for (int j = 0; j &amp;lt;= col; ++j) sum[0][j] = 0;
    for (int i = 0; i &amp;lt;= row; ++i) sum[i][0] = 0;

    for (int i = 0; i &amp;lt; row; ++i) {
        for (int j = 0; j &amp;lt; col; ++j) {
            sum[i+1][j+1] = matrix[i][j] + sum[i][j+1] + sum[i+1][j] - sum[i][j];
        }
    }

    for (int i = 0; i &amp;lt; row; ++i) {
        for (int k = i + 1; k &amp;lt;= row; ++k) {
            map&amp;lt;int, int&amp;gt; m;
            for (int j = 0; j &amp;lt;= col; ++j) {
                // 计算两个矩阵的差，如果差已经在map里面，说明这两个矩阵差相等的这两个矩阵之间就是那个矩阵和为0的子矩阵
                int diff = sum[k][j] - sum[i][j];
                if (m.find(diff) != m.end()) {
                    int l = m[diff];
                    ret[0][0] = i;
                    ret[0][1] = l;
                    ret[1][0] = k - 1;
                    ret[1][1] = j - 1;
                    return ret;
                } else m[diff] = j;
            }
        }
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 连续子数组求和</title>
      <link>https://shiweihou.github.io/lintcode/20161006-4/</link>
      <pubDate>Thu, 06 Oct 2016 21:16:05 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-4/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大。输出答案时，请分别返回第一个数字和最后一个数字的下标。（如果两个相同的答案，请返回其中任意一个）&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定&lt;code&gt;[-3, 1, 3, -3, 4]&lt;/code&gt;,返回&lt;code&gt;[1, 4]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;最大连续子数组问题，只要在求最大连续子数组和的过程中，记录最大值更改时的下标start和end就可以。利用动态规划来求最大子数组，因为要求是连续的，设dp[i]为第i个位置子数组的最大值。第i个位置的数要不要放进去，就要看如果第i个位置放进去，与dp[i-1]的和是否大于A[i],如果大于，就放进去，否则不放。时间复杂度O(n),代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; continuousSubarraySum(vector&amp;lt;int&amp;gt;&amp;amp; A) {
    // Write your code here
    vector&amp;lt;int&amp;gt; ret;
    if (A.empty()) return ret;
    int n = A.size();
    vector&amp;lt;int&amp;gt; cur(n,0);
    int maxSum = A[0];
    cur[0] = A[0];
    int curStart = 0;
    int start = 0;
    int end = 0;
    for (int i = 1; i &amp;lt; n; ++i) {
        if (cur[i-1] + A[i] &amp;gt; A[i]) { // 放进去，curs s e均不作更改
            cur[i] = cur[i-1] + A[i];
        } else {
            cur[i] = A[i];
            curStart = i;
        }
        if (cur[i] &amp;gt; maxSum) {
            maxSum = cur[i];
            start = curStart;
            end   = i;
        }
    }

    ret.push_back(start);
    ret.push_back(end);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 排序矩阵中的从小到大第k个数</title>
      <link>https://shiweihou.github.io/lintcode/20161006-3/</link>
      <pubDate>Thu, 06 Oct 2016 21:08:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-3/</guid>
      <description>&lt;p&gt;题目要求：&lt;/p&gt;

&lt;p&gt;在一个排序矩阵中找从小到大的第 k 个整数。排序矩阵的定义为：每一行递增，每一列也递增。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定 K = 4 和一个排序矩阵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
 [1,5,7],
 [3,7,8],
 [4,8,9],
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回答案 5&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始想错了，以为第i行的数字一定比第i+1行的数字要小，其实题目只要求每一行是递增，每一列数字是递增的，但并没有要求第i行的最后一个数字一定比第i+1行的倒数第二个数字小。我一开始是这样认为的，然后写好提交，发现居然过了73%的test，好神奇~~&lt;/p&gt;

&lt;p&gt;后来发现需要利用堆来做，利用STL里的堆模板，很容易写出来，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int k) {
    // write your code here
    int row = matrix.size();
    if (row == 0 || k == 0) return 0;
    int col = matrix[0].size();

    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;gt;&amp;gt; dui; //构建最小堆
    map&amp;lt;pair&amp;lt;int, int&amp;gt;, bool&amp;gt; visited;

    dui.push(make_pair(matrix[0][0], make_pair(0,0)));
    visited[make_pair(0,0)] = true;

    while (k--) {
        pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt; cur = dui.top();
        dui.pop();

        if (k == 0) return cur.first;

        int x = cur.second.first + 1; // down
        int y = cur.second.second;
        if (x &amp;lt; row &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
        --x;
        ++y;//right-&amp;gt;

        if (y &amp;lt; col &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 硬币排成线||</title>
      <link>https://shiweihou.github.io/lintcode/20161006-2/</link>
      <pubDate>Thu, 06 Oct 2016 20:46:56 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-2/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值高的人获胜。&lt;/p&gt;

&lt;p&gt;请判定 第一个玩家 是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定数组 A = [1,2,2],返回true&lt;/li&gt;
&lt;li&gt;给定数组 A = [1,2,4],返回false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;这道题看上去和前面那道硬币排线题很像，只不过第一个玩家赢的条件从是否能拿到最后一枚硬币变成第一个玩家拿到的硬币价值总和是否大于第二个玩家拿到的硬币价值总和。典型的博弈论题目，每个人都尽量在保证自己获得最大价值的情况下让对方获得最小价值。设第一个玩家为player1，第二个玩家为player2，v[i]为player1从硬币i到end所能拿到的最大价值。我们从后往前推：
对于硬币i和硬币i+1，player1有两种情况可以选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拿走硬币i，获得的价值为values[i]: 在player1拿走硬币i的情况下，那么player2有两种可以选择，一是拿走硬币i+1，那么此时player1拿走硬币i获得的价值就为 v1 = values[i] + v[i+2];二是拿走硬币i和硬币i+1,那么此时player1拿走硬币i获得的价值为 v2 = values[i] + v[i+3]。当然在博弈原则下，player2肯定是想让player1获得的价值最小，所以player1在拿走硬币i获得的最大价值为 choose1 = values[i] + min(v[i+2], v[i+3]).&lt;/li&gt;
&lt;li&gt;拿走硬币i和硬币i+1，获得的价值为values[i+1] + values[i]: 同上所述，player2同样有两种选择，一是拿走硬币i+2和硬币i+3，此时player1所能获得的最大价值为 v3 = values[i] + values[i+1] + v[i+4];二是拿走硬币i+2，此时player1所能获得的最大价值为 v4 = values[i] + values[i+1] + v[i+3]。同样基于博弈，player2肯定想让player1获得的最大价值最小，所以player1在拿走硬币i和硬币i+1的情况下获得的最大价值为 choose2 = values[i] + values[i+1] + min(v[i+3], v[i+4]).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，player1在两种选择下，要选择一个最大的价值 v[i] = max(choose1, choose2).
代码如下，注意越界情况，所以我定义v的数组时多定义了两个，并且设置为0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool firstWillWin(vector&amp;lt;int&amp;gt; &amp;amp;values) {
    // write your code here
    if (values.empty()) return false;

    int len = values.size();
    if (len &amp;lt;= 2) return true;
    vector&amp;lt;int&amp;gt; v(len+2,0);
    v[len-1] = values[len-1];
    v[len-2] = values[len-1] + values[len-2];
    int sum = values[len-1] + values[len-2];
    for (int i = len - 3; i &amp;gt;= 0; --i) {
        sum += values[i];
        int choose1, choose2;
        choose1 = values[i] + min(v[i+2], v[i+3]);
        choose2 = values[i] + values[i+1] + min(v[i+4],v[i+3]);
        v[i] = max(choose1, choose2);
    }

    return sum-v[0] &amp;lt; v[0];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode-硬币排成线</title>
      <link>https://shiweihou.github.io/lintcode/20161006/</link>
      <pubDate>Thu, 06 Oct 2016 20:29:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有N个硬币排成一条线，两个参赛者轮流从右边依次拿走1个或2个硬币，直到没有硬币为止。拿到最后一个硬币的玩家获胜。请判定第一个玩家是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;n = 1, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 2, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 3, 返回 false&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 4, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 5, 返回 true
思路：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这道题是有关博弈论的初级题目。题目很简单，就是判断第一个人最后能否拿到最后一枚硬币。我们不能依赖于第二个玩家怎么拿，我们需要的答案是无论第二个玩家怎么拿，第一个玩家在现有的拿法下（每次拿一个或者两个）可以拿到最后一个硬币或者拿不到。很明显，当只剩下三个硬币的时候，无论第一个玩家怎么拿，最后一个硬币都有可能不是他的，也就是说第一个玩家没有机会获胜。因此，我们只需要判断当还剩下三个的时候，最后一个拿硬币的人是否是第一个人就可以了，很明显可以用递归来做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n) {
        // write your code here
        if (n &amp;lt;= 0 || n == 3) return false;
        else if (n &amp;lt;= 4) return true;
        return firstWillWin(n-3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理，亦可以利用动态规划来做，因为第i个硬币是否为第一个人拿和第i-3个硬币是否是第一个人拿真假值相同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        vector&amp;lt;bool&amp;gt; dp(n + 1, false);
        dp[0] = false;
        dp[1] = true;
        dp[2] = true;
        dp[3] = false;
        for (int i = 4; i &amp;lt;= n; ++i) {
            dp[i] = dp[i-3];
        }
        return dp[n];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种更为简洁的数学方法，因为我们发现如果硬币的个数不是3的倍数，那么第一个人就可以拿到最后一个硬币：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        if (n &amp;lt;= 0) return false;
        if (n % 3 == 1 || n % 3 == 2) return true;
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>全排列问题</title>
      <link>https://shiweihou.github.io/algorithm/%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 04 Oct 2016 20:34:33 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>

&lt;h2 id=&#34;全排列的非递归实现&#34;&gt;全排列的非递归实现：&lt;/h2&gt;

&lt;p&gt;考虑排列 “926520”这个字符串，它的下一个排列是哪一个呢？我们从后往前开始找，找到第一组相邻数字递增的组合：0-2-5-6 都不行，但 6-2可以，即 2 和 6 这组数字是从后往前数，第一组递增的。这时候，2 即为 替换数， 替换数的下标称之为替换点。找到替换点之后，从替换点开始，向后找到一个比替换点大的数里面最小的那个大数，即为 5，这时候，将 5 和2进行交换，得到956220，再将替换点之后的数进行反转，得到950226 ，这时候这个排列就是下一个排列。对于像54321这种已经是最后一个排列的全排列，其下一个排列当然为12345 。&lt;/p&gt;

&lt;p&gt;对于从替换点开始，找到后面最小的大数，我们可以从后往前找，因为除了替换点和替换点后面的数之外，其余的都是递减的（从前往后看），所以最右边的第一个大于替换数的数一定是最小的大数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void nextPermutation(vector&amp;lt;int&amp;gt; &amp;amp;nums) {

    if (nums.empty()) return ;
    int len = nums.size();
    int i = len - 1;
    bool flag = false;

    while (i &amp;gt; 0 ) { // 找替换点
        if (nums[i] &amp;lt;= nums[i - 1]) --i;
        else {
            flag = true;
            break;
        }
    }

    if (flag == false) reverse(nums.begin(), nums.end());
    else {
        --i;
        int j = i + 1;
        int pos = j;
        while (j &amp;lt; len) { // 找替换点之后最小的大数
            if (nums[j] &amp;gt; nums[i]) {
                if (nums[j] &amp;lt;= nums[pos]) pos = j;
            }
            ++j;
        }
        swap(nums[i], nums[pos]);
        ++i;
        j = len - 1;  
        while (i &amp;lt; j) swap(nums[i++], nums[j--]);  // 反转
    }

    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一种另类的全排列问题&#34;&gt;一种另类的全排列问题：&lt;/h2&gt;

&lt;p&gt;给你一个排列，问这是在所有的全排列中，第几个排列？排列序号从1开始，按顺序增长的方向开始。排列中不包含重复数字。例如给定排列124，它是第一个排列。看到这个题目首先想到的就是求出所有的全排列，然后在求解过程中与给出的排列进行比较，看看是第几个。思路是ok的，然而在oj上面会超时，说明这个方法不行。也就说其实不是要让你求出所有的排列然后进行比较，而是化成组合问题，在这个排列前，有多少个排列。&lt;/p&gt;

&lt;p&gt;例如对于排列  list = 95412：
在排列list前面的所有的全排列中，位于位置1的数字可能是5、4、1、2中的任意一个数，而一旦位置1确定了，其全排列个数为4！（5-1）个。
同理，对应位置2的数字可以是4、 1、 2的任意一个，而一旦位置2确定了，其全排列个数为3！（5-2）个。
同理，对应位置3的数字可以是1 、 2的任意一个，而一旦位置3确定了，其全排列个数为2！（5-3）个。
同理，对应位置4的数字可以是0个（因为没有数字比1还小），一旦位置4确定了，其全排列个数为1！（5-4）个。
最后，对应位置5的数字可以是0个，全排列个数为0！（5-5）个。
从上面我们就可以看出，对于一个给定的排列，求出其在全排列的的序号，只需要对给定的序列进行查找，找到从位置2开始一直到倒数第二个位置可变数字的个数（就是该位置后面的，比当前位置数字小的）*（n-i）!.
即，对于位置 i （i &amp;gt;= 0 &amp;amp;&amp;amp;  i&amp;lt; n-1）,其后面的数字比当前 i 位置小的个数为 k 个，则其排列个数为 k * (n - i - 1)! 个。对这个排列整个遍历一遍，就得到当前排列之前的全排列个数。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long long permutationIndex(vector&amp;lt;int&amp;gt;&amp;amp; A) {

    map&amp;lt;int, int&amp;gt; mapCount;
    for (int i = 0; i &amp;lt; A.size() - 1; ++i) {
        int count = 0;
        for (int j = i + 1; j &amp;lt; A.size(); ++j) {
            if (A[i] &amp;gt; A[j]) {
                ++count;
            }
        }
        // 保存i个位置后面有多少个比它小的
        mapCount[A[i]] = count;
    }

    long ans = 0;
    int n = A.size();
    for (int i = 0; i &amp;lt; A.size() - 1; ++i) {
        int k = n - i - 1;
        long fact = 1;
        // 当前位置的阶乘
        while (k &amp;gt; 0) {  
            fact *= k;
            --k;
        }
        // 阶乘 * k
        ans += mapCount[A[i]] * fact;
    }
    // 因为前面求到的是当前排列前总共有多少个全排列，所以自然当前排列是 ans + 1 个排列
    return ++ans;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一种另类的全排列问题-2&#34;&gt;一种另类的全排列问题 2：&lt;/h2&gt;

&lt;p&gt;类似于前面的问题，只不过是排列中有重复数字，求当前排列是第几个。基于前面的问题来做，假如没有重复数字，那么答案自然是上面那个。因为有重复数字，只要在发现重复数的那一位用 k * (n - i - 1)! 的结果除去重复的次数就行，当然重复的次数也要做阶乘，例如排列中有3个2,4个8，重复次数
为 3！ * 4 ！，代码如下：&lt;/p&gt;

&lt;p&gt;ps: 这段代码说实在没有太懂&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long long permutationIndexII(vector&amp;lt;int&amp;gt;&amp;amp; A) {
    // Write your code here

    long long index = 0, fact = 1, dup = 1;

    map&amp;lt;int, int&amp;gt; mapCount;
    for (int i = A.size()-1; i &amp;gt;= 0; i--) {

        if (mapCount.find(A[i]) == mapCount.end()) mapCount[A[i]] = 1;
        else {

            mapCount[A[i]] += 1;
            dup *= mapCount[A[i]];
        }
        int rank = 0;
        for (int j = i+1; j &amp;lt; A.size(); j++) {
            if (A[j] &amp;lt; A[i]) rank++;
        }
        index += rank * fact / dup;
        fact *= (A.size() - i);
    }
    return index+1;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>最长回文子串</title>
      <link>https://shiweihou.github.io/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 04 Oct 2016 19:27:50 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>&lt;p&gt;回文的意思大家应该都知道，就是一个子串，从前往后读与从后往前读是一模一样的。
最长回文子串的意思就是：在一个给定的字符串中，找到一个最长的回文子串。&lt;/p&gt;

&lt;p&gt;一开始的思路很复杂：例如对于串：&lt;strong&gt;abdcdedcab&lt;/strong&gt;，最长回文子串为 &lt;strong&gt;cdedc&lt;/strong&gt;，我一开始的想法是：对于母串，首先遍历一遍，建立一个&lt;strong&gt;map&lt;/strong&gt;，保存每个字符所在的位置。map类型为&lt;code&gt;map&amp;lt;char,stack&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;,例如对于字符a，它在母串中的位置是 0,8，那么map[a] = [0,8].保留下所有的字符后，因为子串要求是连续的，所以对于母串的每一个不同的字符都遍历一遍，然后在 stack 中找到它出现的另一个位置，例如还是a，它的位置有两个，0和8，那么就判断 0 - 8 之间是否为回文串。这样所有的遍历一遍，找到最长的那个。在Lintcode上，通过了73%的数据，因为我一开始的代码是 &lt;strong&gt;以母串的前面第一个为基准&lt;/strong&gt;，然后以该字符在其它位置出现作为比较，这样其实没法通过类似于 aaaabaaa的数据。我得到的结果为aaaa，而其实答案为aaabaaa。后来我就想了下，其实我只是对该字符在母串中的位置，两两组合，只判断了一部分情况，例如前面的aaaabaaa,对于a，我只判断了位置（0,7）（0，6）（0,5）（0,3）（0,2）（0,1）这几种情况，而没有判断（1,7）（1,6）（1，5）等等这些情况，所以是没办法通过所有测试数据的。后来就用上面的两两组合思想，后来发现和暴搜是一样的，时间复杂度是 O(n^3), TLE。&lt;/p&gt;

&lt;p&gt;后来想到，暴搜的思想是从外往里搜，找到每一个可能的子串，判断是不是回文。这个过程中其实有很多次重复的动作，那么能不能换个思路，从里往外搜。我们知道对于每一个字符，以它为基准，往外扩展，由于是回文，i-1和i+1位置的字符必然相等。通过以上的思想可以得到如下代码：（考虑　aba 和 abba 两种奇偶不同的情况）：时间复杂度为 O(n^2)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 * @param s input string
 * @return the longest palindromic substring
 */
string longestPalindrome(string&amp;amp; s) {
    // Write your code here
    if (s.empty()) return NULL;
    int len = s.size();
    int pos = 0;
    string ans = &amp;quot;&amp;quot;;

    while (pos &amp;lt; len) {
        string s1 = huiwen(s, pos, pos); // aba 的情况
        string s2 = huiwen(s, pos, pos + 1); // abba 的情况
        if (s1.size() &amp;gt; s2.size()) {
            ans = ans.size() &amp;gt; s1.size() ? ans : s1;
        }
        else {
            ans = ans.size() &amp;gt; s2.size() ? ans : s2;
        }
        ++pos;
    }

    return ans;
}

string huiwen(string &amp;amp;s, int ss, int ee) {

    if (ee &amp;gt;= s.size()) return s.substr(ss,1);

    while (ss &amp;gt;= 0  &amp;amp;&amp;amp; ee &amp;lt; s.size()) {
        if (s[ss] != s[ee]) {
            break;
        }
        --ss;
        ++ee;
    }

    if (ss == ee || ss + 1 == ee) return s.substr(ss, 1);
    else return s.substr(ss+1, ee - ss - 1);
}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面的算法思想，可以衍生出很多 O(N^2)的算法，例如动态规划。思想就是设置标志flag[N][N]，如果 s[i] == s[j] &amp;amp;&amp;amp; flag[i+1][j-1] == true，那么 flag[i][j] == true;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 * @param s input string
 * @return the longest palindromic substring
 */
string longestPalindrome(string&amp;amp; s) {
    // Write your code here

    if (s.empty()) return &amp;quot;&amp;quot;;
    int len = s.size();
    vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; flag (len, vector&amp;lt;bool&amp;gt;(len, false));

    for (int i = 0; i &amp;lt; len; ++i) {
        for (int j = 0; j &amp;lt; len; ++j) {
            // 当i==j的时候，单个字符明显为回文
            // 当i &amp;gt; j 的时候，设置为true是为了防止出现 s[i] == s[i+1]这种情况，反正如果不相等在下面又会变成false
            if (i &amp;gt;= j) flag[i][j] = true;
        }
    }

    int ss = 0;
    int maxLen = 1;

    for (int j = 1; j &amp;lt; len; ++j) {
        for (int i = 0; i &amp;lt; j; ++i) {
            if (s[i] == s[j]) {
                if (flag[i+1][j-1]) flag[i][j] = true;
                else flag[i][j] = false;

                if (flag[i][j]) {
                    if (maxLen &amp;lt; j - i + 1) {
                        ss = i;
                        maxLen = j - i + 1;
                    }
                }
            } else flag[i][j] = false;
        }
    }

    return s.substr(ss, maxLen);
    }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网上还有一种算法，Manacher算法，时间复杂度是 O(N)，有兴趣的同学可以去找下。&lt;/p&gt;

&lt;p&gt;另外，有的同学会说，如果把字符串 s 翻转过来，变成 s&amp;rsquo; ,那么求s和s&amp;rsquo;的最长公共连续子序列是不是就是就是答案？其实不是，例如对于串 &lt;strong&gt;abcdefgdcba&lt;/strong&gt;，如果翻转，就变成 &lt;strong&gt;abcdgfedcba&lt;/strong&gt;, 那么最长子序列为 &lt;strong&gt;abcd&lt;/strong&gt; ，但这个明显不是回文的，所以求两个串的最长公共连续子序列并不一定是回文的。当然，如果要求都是不连续的，那么当然可以这样求。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>