<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello world!</title>
    <link>https://shiweiHou.github.io/</link>
    <description>Recent content on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 15 Feb 2017 11:28:33 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>网易2017秋招编程题6</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</link>
      <pubDate>Wed, 15 Feb 2017 11:28:33 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%986/</guid>
      <description>&lt;p&gt;买苹果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    if (n &amp;lt; 6 || n == 7) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    else {
        int n8 = n / 8, n6 ;

        if (n % 8 == 0) n6 = 0;
        else n6 = 1;

        while ( n8 * 8 + n6 * 6 &amp;gt; n) {
            --n8;
            ++n6;
        }

        if (n8 * 8 + n6 * 6 == n) cout &amp;lt;&amp;lt; n6 + n8 &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题5</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</link>
      <pubDate>Wed, 15 Feb 2017 11:18:02 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%985/</guid>
      <description>&lt;p&gt;最大奇约数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
/*思路：
*如果是奇数，直接加上去就行了，如果是偶数，就需要一直除2把它变成奇数，如果直接一个
*一个的加，会超时，因此需要用到一些技巧
*例如，N = 10，那么我们此时一共有 1 2 3 4 5 6 7 8 9 10十个数，里面有10/2=5个奇数 1 3 5 7 9，那么奇数项的和为
*一个等差数列公式：s = n * a1 + (n * (n-1) / 2) * d,其中a1为第一项，n为个数，其实是N/2，d为2，那么我们套用进去
*s = N / 2 + (N / 2) * (N / 2 -1) / 2 * 2 = (N / 2) * (N / 2),又因为当N为奇数的时候，N / 2 == （N + 1） / 2
*所以不管是奇数偶数，都可以用 ((N+1) / 2) * ((N+1) / 2)这个公式求和
*这样我们每一次都把1~N的奇数项求和，剩下的是偶数项，继续 N= N/2 (因为 1 2 3 4 5 6 7 8 9 10将奇数项去掉后
*，还剩下 2 4 6 8 10，他们的最大奇约数其实就是 1 2 3 4 5的最大奇约数，所以求N/2的和就行了）求 1~N 的和，直到0
*/
int main() {
    long long N, sum = 0;
    cin &amp;gt;&amp;gt; N;
    for (long long i = N; i &amp;gt; 0; i /= 2) {
        sum += ((i+1) / 2) * ((i+1) / 2);
    }
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题4</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</link>
      <pubDate>Wed, 15 Feb 2017 11:00:24 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%984/</guid>
      <description>&lt;p&gt;数字翻转：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

int rev(int num){
    vector&amp;lt;int&amp;gt; digit; 
    int t = 0; // 记录位数
    while (num) {
        digit.push_back(num % 10);
        num /= 10;
        ++t;
    }
    num = 0;
    for (int i = 0; i &amp;lt; t ; ++i) {
        num = num * 10 + digit[i];
    }
    return num;
}

int main() {
    int x, y;
    cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
    cout &amp;lt;&amp;lt; rev(rev(x) + rev(y)) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题3</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</link>
      <pubDate>Wed, 15 Feb 2017 10:53:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%983/</guid>
      <description>&lt;p&gt;跳石板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

void find_yue_shu(int num, vector&amp;lt;int&amp;gt; &amp;amp;yue_shu) {
    for (int i = 2; i &amp;lt;= sqrt(num); ++i) {
        if (num % i == 0) {
            yue_shu.push_back(i);
            if (num / i != i) yue_shu.push_back(num / i);
        }
    }

}

int fuc(int N, int M) {
    if (N == M) return 0;
    vector&amp;lt;int&amp;gt; dp(M+1, -1);
    dp[N] = 0;
    for (int i = N; i &amp;lt;= M; ++i) {
        if (dp[i] == -1) continue; // 说明该点无法到达
        vector&amp;lt;int&amp;gt; yue_shu;
        find_yue_shu(i, yue_shu);
        for (int j = 0; j &amp;lt; yue_shu.size(); ++j) {
            int pos = yue_shu[j] + i; // 根据这个约数能到达的台阶位置
            if (pos &amp;lt;= M &amp;amp;&amp;amp; dp[pos] != -1) { // 这个位置小于M，并且该位置已经可以到达了，就要进行比较,否则直接+1
                dp[pos] = min(dp[pos] , dp[i] + 1);
            } else if (pos &amp;lt;= M) {
                dp[pos] = dp[i] + 1;
            }
        }
    }

    if (dp[M] == -1) return -1;
    return dp[M];
}

int main() {
    int N, M;
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;
    cout &amp;lt;&amp;lt; fuc(N, M) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题2</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</link>
      <pubDate>Wed, 15 Feb 2017 10:30:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%982/</guid>
      <description>&lt;p&gt;优雅的点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main() {
    int rr;
    cin &amp;gt;&amp;gt; rr;
    int r = (int)sqrt(rr);
    int sum = 0;

    for (int i = r; i &amp;gt;= 0; --i) {
        // 只计算第一象限的点
        int j = (int)sqrt(rr - i * i);
        if (i * i + j * j == rr) ++sum;
    }
    sum *= 4;
    // 如果半径本身就是整数点，那么相当于重复计算了四个轴的四个点，需要减去4
    if (r * r == rr) sum -= 4;
    cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>网易2017秋招编程题1</title>
      <link>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981/</link>
      <pubDate>Wed, 15 Feb 2017 10:13:38 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/algorithm/%E7%BD%91%E6%98%932017%E7%A7%8B%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981/</guid>
      <description>&lt;p&gt;牛课网上做的：
回文序列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;deque&amp;gt;
using namespace std;

bool is_hui_wen(deque&amp;lt;int&amp;gt; &amp;amp;dq) { // 判断是不是回文序列
    if (dq.empty()) return true;
    deque&amp;lt;int&amp;gt;::iterator beg = dq.begin();
    deque&amp;lt;int&amp;gt;::iterator en  = dq.end();
    --en;
    while ( beg &amp;lt; en) {
        if (*beg != *en) return false;
        ++beg;
        --en;
    }
    return true;
}

int min_change(deque&amp;lt;int&amp;gt; &amp;amp;dq) {
    int t = 0;
    while (!is_hui_wen(dq)) {// 如果不是，继续进行处理
        int b1 = *(dq.begin());
        dq.pop_front();
        int c1 = *(--dq.end());
        dq.pop_back();
        if (b1 == c1) continue; // 相等说明这个序列前后数字相同，略过，查看剩下的序列
        if (dq.empty() == false) { // 如果序列中还有其它元素
            if (b1 &amp;gt; c1) { // 前面的大，说明后面的需要两个数相加
                dq.push_front(b1);
                int c2 = *(--dq.end());
                c1 += c2;
                dq.pop_back();
                dq.push_back(c1);
            } else if (b1 &amp;lt; c1) { // 否则，前面的两个数相加
                dq.push_back(c1);
                int b2 = *(dq.begin());
                b1 += b2;
                dq.pop_front();
                dq.push_front(b1);
            }
        }
        ++t;
    }
    return t;
}

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    deque&amp;lt;int&amp;gt; dq; // 利用双向队列来做，比较方便
    for (int i = 0; i &amp;lt; n; ++i) {
        int num;
        cin &amp;gt;&amp;gt; num;
        dq.push_back(num);
    }
    cout &amp;lt;&amp;lt; min_change(dq) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 表达树构造</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-03/</link>
      <pubDate>Sun, 25 Dec 2016 16:47:22 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-03/</guid>
      <description>&lt;p&gt;看到这个题目就感觉和前两天做的“逆波兰表达式”很像，想的方法就是先将表达式转化成逆波兰表达式，因为逆波兰表达式就是后缀表达式，维护一个栈，从头开始遍历后缀表达式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;碰到数值，就生成个结点，然后将结点指针放入栈中&lt;/li&gt;
&lt;li&gt;碰到操作数，就在栈中弹出两个指针作为该操作数的右左子树，接着将指向操作数的指针入栈&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到最后栈中就只会剩下根节点了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition of ExpressionTreeNode:
 * class ExpressionTreeNode {
 * public:
 *     string symbol;
 *     ExpressionTreeNode *left, *right;
 *     ExpressionTreeNode(string symbol) {
 *         this-&amp;gt;symbol = symbol;
 *         this-&amp;gt;left = this-&amp;gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param expression: A string array
     * @return: The root of expression tree
     */
    ExpressionTreeNode* build(vector&amp;lt;string&amp;gt; &amp;amp;expression) {
        // write your code here
        // 首先将表达式转换为逆波兰表达式，也就是表达树的后缀表示形式
        vector&amp;lt;string&amp;gt; nibolan;
        stack&amp;lt;string&amp;gt; operat;
        operat.push(&amp;quot;@&amp;quot;);
        int i = 0;
        while ( i &amp;lt; expression.size()) {
            string s = expression[i];
            if (s != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;/&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;(&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;)&amp;quot;) {
                nibolan.push_back(s);

        } else if ( s == &amp;quot;(&amp;quot;) {
            operat.push(s);

        } else if ( s == &amp;quot;)&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.pop();
        } else if ( s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; (top == &amp;quot;*&amp;quot; || top == &amp;quot;/&amp;quot;) ) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s);
        } else {
           string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s); 
        }
        ++i;
    }
    string top = operat.top();
    while (top != &amp;quot;@&amp;quot; ) {
        nibolan.push_back(top);
        operat.pop();
        top = operat.top();
    }
    //从前往后，根据后缀表达式构建表达树,维护一个栈，栈中存放着树的指针，如果是操作符，就从栈中弹出两个指针作为它的右左子树，如果是数字，就直接入栈，最后栈中只会留下根指针
    stack&amp;lt;ExpressionTreeNode*&amp;gt; st;
    i = 0;
    while (i &amp;lt; nibolan.size()) {
        string s = nibolan[i];
        ExpressionTreeNode * node = new ExpressionTreeNode (s);
        if (s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot; || s == &amp;quot;+&amp;quot; || s == &amp;quot;-&amp;quot;) {
            ExpressionTreeNode* right = st.top();
            st.pop();
            ExpressionTreeNode* left = st.top();
            st.pop();
            node-&amp;gt;left = left;
            node-&amp;gt;right = right;
        }
        st.push(node);
        ++i;
    }
    if (st.empty()) return NULL;
    return st.top();

}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 用栈模拟汉诺塔问题</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-02/</link>
      <pubDate>Sun, 25 Dec 2016 16:41:24 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-02/</guid>
      <description>&lt;p&gt;我们知道汉诺塔问题是个经典的递归问题，思路就是有三根柱子 A B C，将N个按大小排好的碟子从A移动到C上，每次只移动一个并且只能将小的放在大的上面。将N-1个碟子利用柱子B从A放在B上，再将第N个碟子从A移动到C上，然后将剩下的N-1个碟子从B再移动到A上，重复这个过程，直到所有的碟子都移动完毕。根据Lintcode提供的接口，我们只需要补充完整就好了，在做的过程中也遇到了一些小问题，在代码里都注释了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Tower {
public:
    // create three towers (i from 0 to 2)
    Tower(int i) {}

    // Add a disk into this tower
    void add(int d) {
        if (!disks.empty() &amp;amp;&amp;amp; disks.top() &amp;lt;= d) {
            printf(&amp;quot;Error placing disk %d&amp;quot;, d);
        } else {
            disks.push(d);
        }
    }

    // @param t a tower
    // Move the top disk of this tower to the top of t.
    void moveTopTo(Tower &amp;amp;t) {
        // Write your code here
        //不明白加上这句if (disks.top() &amp;gt; t.disks.top())为什么错误
        //1是没有考虑到disks是private，不能直接由对象调用，2是没有判断t的disnks是不是空的，所以才出错
        //if (disks.top() &amp;gt; t.disks.top()) ;
        stack&amp;lt;int&amp;gt; s = t.getDisks();
        if (!s.empty() &amp;amp;&amp;amp; disks.top() &amp;gt; s.top()) ;
        t.add(disks.top());
        disks.pop();

    }

    // @param n an integer
    // @param destination a tower
    // @param buffer a tower
    // Move n Disks from this tower to destination by buffer tower
    void moveDisks(int n, Tower &amp;amp;destination, Tower &amp;amp;buffer) {
        // Write your code here
        if (n == 0) return ;
        else if (n == 1) moveTopTo(destination);
        else {
            moveDisks(n-1,buffer,destination);
            moveTopTo(destination);
            buffer.moveDisks(n-1,destination,*this);
        }

    }

    stack&amp;lt;int&amp;gt; getDisks() {
        return disks;
    }

private:
    stack&amp;lt;int&amp;gt; disks;
};
/**
 * Your Tower object will be instantiated and called as such:
 * vector&amp;lt;Tower&amp;gt; towers;
 * for (int i = 0; i &amp;lt; 3; i++) towers.push_back(Tower(i));
 * for (int i = n - 1; i &amp;gt;= 0; i--) towers[0].add(i);
 * towers[0].moveDisks(n, towers[2], towers[1]);
 * print towers[0], towers[1], towers[2]
*/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 矩阵的之字型遍历</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-01/</link>
      <pubDate>Sun, 25 Dec 2016 16:33:35 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-01/</guid>
      <description>&lt;p&gt;题目要求：给一个矩阵，按照之字型进行遍历，&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/matrix-zigzag-traversal/&#34;&gt;题目链接&lt;/a&gt;
思路：其实仔细想一想，就是先斜着往下遍历，再斜着往上遍历，就是这个过程，主要是判断好临界条件，是要往右走还是往下走
代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param matrix: a matrix of integers
     * @return: a vector of integers
     */
    vector&amp;lt;int&amp;gt; printZMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix) {
        // write your code here
        int row = matrix.size();
        int col = matrix[0].size();
        vector&amp;lt;int&amp;gt; ret (row * col, 0);
        int r = 0;
        int c = 0;
        int i = 0;
        int all = row * col;
        ret[i++] = matrix[0][0];
        while (i &amp;lt; all) {
            // 斜上走到顶
            while (i &amp;lt; all &amp;amp;&amp;amp; r - 1 &amp;gt;= 0 &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[--r][++c];
            }
            // 横右走一步，不可横右走时竖下走一步
            if (i &amp;lt; all &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[r][++c];
            } else if (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row) {
                ret[i++] = matrix[++r][c];
            }
            // 斜下走到底
            while (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row &amp;amp;&amp;amp; c - 1 &amp;gt;= 0) {
                ret[i++] = matrix[++r][--c];
            }
            // 竖下走一步，不可竖下时横右走一步
            if (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row) {
                ret[i++] = matrix[++r][c];
            } else if (i &amp;lt; all &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[r][++c];
            }
        }
        return ret;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 将表达式转换为逆波兰表达式</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-22-01/</link>
      <pubDate>Thu, 22 Dec 2016 20:55:54 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-22-01/</guid>
      <description>&lt;p&gt;问题描述：
    给定一个表达式字符串数组，返回该表达式的逆波兰表达式。&lt;/p&gt;

&lt;p&gt;问题分析：首先要搞明白什么是逆波兰表达式，&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&#34;&gt;wiki&lt;/a&gt;上面有很详细的介绍，题目意思就是将我们平常习惯的数学表达式表示成计算机所能理解的式子。因为人类可以很自然的理解例如&lt;code&gt;1 + 2 * 3&lt;/code&gt;这样的式子，但计算机没有办法，计算机需要将其转换为&lt;code&gt;123*+&lt;/code&gt;这样的形式才可以。&lt;/p&gt;

&lt;p&gt;前面有一道题是将逆波兰表达式转换为中缀表达式，这道题刚好反过来。其实如果我们首先先自己在草稿纸上自己将中缀表达式转为逆波兰表达式的过程演算一遍，就很自然的明白转换规则：假设我们有一个&lt;code&gt;vector ret&lt;/code&gt;用来专门存答案，有一个&lt;code&gt;stack opera&lt;/code&gt;用来存操作符（&lt;code&gt;+ - * / （&lt;/code&gt;） ），另字符串&lt;code&gt;ch&lt;/code&gt;为表达式&lt;code&gt;expression&lt;/code&gt;中的元素，规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;假如&lt;code&gt;ch&lt;/code&gt;为数字，那么很自然的，将其放入&lt;code&gt;ret&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;假如&lt;code&gt;ch&lt;/code&gt;为操作符，那么：

&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch == &amp;quot;(&amp;quot;&lt;/code&gt;,那么将&lt;code&gt;ch&lt;/code&gt;放入到&lt;code&gt;opera&lt;/code&gt;中；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch == &amp;quot;)&amp;quot;&lt;/code&gt;,那么将&lt;code&gt;opera&lt;/code&gt;中最顶层的&lt;code&gt;（&lt;/code&gt;上面的所有操作符放入&lt;code&gt;ret&lt;/code&gt;中&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch
是四则运算符&lt;/code&gt;,那么根据此时&lt;code&gt;opera&lt;/code&gt;中已有的字符的优先级，如果&lt;code&gt;ch&lt;/code&gt;大于此时&lt;code&gt;opera&lt;/code&gt;顶层操作符的优先级，那么&lt;code&gt;ch&lt;/code&gt;放入到&lt;code&gt;opera&lt;/code&gt;中，如果不是，那么将&lt;code&gt;opera&lt;/code&gt;中的运算符弹出放入&lt;code&gt;ret&lt;/code&gt;中，直到碰到第一个大于&lt;code&gt;ch&lt;/code&gt;的优先级的运算符或者碰到第一个&lt;code&gt;（&lt;/code&gt;或者走到头。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们首先放进去一个字符@，表示优先级最低或者表示栈底
代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param expression: A string array
     * @return: The Reverse Polish notation of this expression
     */
    vector&amp;lt;string&amp;gt; convertToRPN(vector&amp;lt;string&amp;gt; &amp;amp;expression) {
        // write your code here
        vector&amp;lt;string&amp;gt; nibolan;
        stack&amp;lt;string&amp;gt; operat;
        operat.push(&amp;quot;@&amp;quot;);
        int i = 0;
        while ( i &amp;lt; expression.size()) {
            string s = expression[i];
            if (s != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;/&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;(&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;)&amp;quot;) {
                nibolan.push_back(s);

            } else if ( s == &amp;quot;(&amp;quot;) {
                operat.push(s);

            } else if ( s == &amp;quot;)&amp;quot;) {
                string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.pop();
            } else if ( s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot;) {
                string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; (top == &amp;quot;*&amp;quot; || top == &amp;quot;/&amp;quot;) ) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.push(s);
            } else {
               string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.push(s); 
            }
            ++i;
        }
        string top = operat.top();
        while (top != &amp;quot;@&amp;quot; ) {
            nibolan.push_back(top);
            operat.pop();
            top = operat.top();
        }

        return nibolan;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ex9-10.The end</title>
      <link>https://shiweihou.github.io/machinelearning/exend/</link>
      <pubDate>Sat, 17 Dec 2016 15:03:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/machinelearning/exend/</guid>
      <description>&lt;p&gt;第九周和第十周没有再讲具体的算法了，而是介绍了一些机器学习变种的算法。第九周介绍了如何在非常非常大的数据下进行机器学习，以及流算法，第十周则介绍了流水线工作，类似于模块化，将一个大的机器学习任务分解成几个小部分，然后分析哪部分可以进行改进，哪部分不需要花费太多的人力物力物改进。&lt;/p&gt;

&lt;p&gt;总之，感觉正学习的渐入佳境，突然就没了，总有一种意犹未尽的感觉。机器学习只是比较有兴趣，然而现在我用到的机会却不是很多，希望可以继续学习下去，获得更多的知识。&lt;/p&gt;

&lt;p&gt;再次感谢Andrew Ng的无私奉献，还有Coursera平台提供了这次机会，再次感谢！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;按行读取文本字符串</title>
      <link>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 13 Dec 2016 16:55:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/cplusplus/C&#43;&#43;%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;我们有一个文本文件，文件信息都是按行存储的，并且每行都包含很多字符串，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;you are my girl!
This is number 123456!
Do you like me? aha
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于这样，我们有时候可能希望不仅仅读取文本里的字符串，还希望能够按行读取，因为有时候文本里的内容是相关的，即每行的信息大同小异，但每行间又会有点小区别，或者我们希望处理某特定一行的数字等等。这时我们希望可以每次读取一行，然后把每行的字符串都拆分出来，我们就可以按照下面的操作：
std::fstream
C++ 有一个头文件&lt;code&gt;&amp;lt;fstream&amp;gt;&lt;/code&gt;,里面有三个类成员 &lt;code&gt;fstream ifstream ofstream&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ifstream：定义读取的文件，进行读操作，而无法进行写操作&lt;/li&gt;
&lt;li&gt;ofstream：定义要写的文件，进行写操作，而无法进行读操作&lt;/li&gt;
&lt;li&gt;fstream：定义读写文件，既可以进行读操作，也可以进行写操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一行一行的读取文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;fstream&amp;gt;

std::string fileName = &amp;quot;line.ply&amp;quot;;
std::ifstream input_file(fileName.c_str());
std::string line;
if (input_file.is_open()) {
    while (getline(input_file, line)) {
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl; // 文件每一行的数据都保存在line中
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上式中&lt;code&gt;getline&lt;/code&gt;函数，就将每一行的内容都放入line中，直到读取到末尾。&lt;/p&gt;

&lt;p&gt;那么现在我们得到每行的数据了，如何得到每行单独的字符串呢，这时候就要用到&lt;code&gt;sstream&lt;/code&gt;，它和&lt;code&gt;fstream&lt;/code&gt;类似，不过前者是对文件进行操作，是文件IO，后者是对string对象操作，就像string是一个IO流一样。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;istringstream：从string读取数据&lt;/li&gt;
&lt;li&gt;ostringstream：向string写入数据&lt;/li&gt;
&lt;li&gt;stringstream：对string既可以写，也可以读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对上面得到的一行数据进行操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;sstream&amp;gt;
std::istringstream text(line);
std::string content;
while (text &amp;gt;&amp;gt; content) {
    do something with content.//这时我们就将一行的数据拆分成单个的字符串，就可以进行操作了
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ex8.Anomaly Detection and Recommender Systems</title>
      <link>https://shiweihou.github.io/machinelearning/ex8/</link>
      <pubDate>Sat, 03 Dec 2016 18:03:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/machinelearning/ex8/</guid>
      <description>

&lt;p&gt;这节课主要讲了如何进行异常检测，介绍了推荐系统的基本概念和如何搭建一个推荐系统，都是一些基础概念，比较简单。
已经第九周了，还有两周的课就结束了，↖加油(^ω^)↗&lt;/p&gt;

&lt;h2 id=&#34;estimategaussian-m&#34;&gt;estimateGaussian.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [mu sigma2] = estimateGaussian(X)
%ESTIMATEGAUSSIAN This function estimates the parameters of a 
%Gaussian distribution using the data in X
%   [mu sigma2] = estimateGaussian(X), 
%   The input X is the dataset with each n-dimensional data point in one row
%   The output is an n-dimensional vector mu, the mean of the data set
%   and the variances sigma^2, an n x 1 vector
% 
% Useful variables
[m, n] = size(X);
% You should return these values correctly
mu = zeros(n, 1);
sigma2 = zeros(n, 1);

% ====================== YOUR CODE HERE ======================
% Instructions: Compute the mean of the data and the variances
%               In particular, mu(i) should contain the mean of
%               the data for the i-th feature and sigma2(i)
%               should contain variance of the i-th feature.
%
% X 是m行n列，sum（X)将每一列的和加起来然后除去行数m得到一个1*n维的行向量，进行转置，得到列向量
mu = (sum(X)/m)&#39;;

mu2 = mu&#39;;%将mu变成原来1*n维的行向量[1 2 3 .. n]
%mu2(ones(m,1),:)是将一个1*n维的行向量变成m*n的矩阵，即复制了m次，此时mu2就变成了
%    [u1,u2,u3,...,un
%     u1,u2,u3,...,un
%     .
%     .
%     u1,u2,u3,...,un
sigma2 = (sum((X - mu2(ones(m,1),:)).^2) / m )&#39;;
% =============================================================
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;selectthreshold-m&#34;&gt;selectThreshold.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [bestEpsilon bestF1] = selectThreshold(yval, pval)
%SELECTTHRESHOLD Find the best threshold (epsilon) to use for selecting
%outliers
%   [bestEpsilon bestF1] = SELECTTHRESHOLD(yval, pval) finds the best
%   threshold to use for selecting outliers based on the results from a
%   validation set (pval) and the ground truth (yval).
%

bestEpsilon = 0;
bestF1 = 0;
F1 = 0;

stepsize = (max(pval) - min(pval)) / 1000;
for epsilon = min(pval):stepsize:max(pval)

    % ====================== YOUR CODE HERE ======================
    % Instructions: Compute the F1 score of choosing epsilon as the
    %               threshold and place the value in F1. The code at the
    %               end of the loop will compare the F1 score for this
    %               choice of epsilon and set it to be the best epsilon if
    %               it is better than the current choice of epsilon.
    %               
    % Note: You can use predictions = (pval &amp;lt; epsilon) to get a binary vector
    %       of 0&#39;s and 1&#39;s of the outlier predictions

    predictions = (pval &amp;lt; epsilon);
    fp = sum((predictions == 1) &amp;amp; (yval == 0));
    tp = sum((predictions == 1) &amp;amp; (yval == 1));
    fn = sum((predictions == 0) &amp;amp; (yval == 1));
    prec = tp / (tp + fp);
    rec = tp / (tp + fn);
    F1 = 2 * prec * rec / (prec + rec);
    % =============================================================
    if F1 &amp;gt; bestF1
       bestF1 = F1;
       bestEpsilon = epsilon;
    end
end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;coficostfunc-m&#34;&gt;cofiCostFunc.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function [J, grad] = cofiCostFunc(params, Y, R, num_users, num_movies, ...
                              num_features, lambda)
%COFICOSTFUNC Collaborative filtering cost function
%   [J, grad] = COFICOSTFUNC(params, Y, R, num_users, num_movies, ...
%   num_features, lambda) returns the cost and gradient for the
%   collaborative filtering problem.
%

% Unfold the U and W matrices from params
X = reshape(params(1:num_movies*num_features), num_movies, num_features);
Theta = reshape(params(num_movies*num_features+1:end), ...
                num_users, num_features);


% You need to return the following values correctly
J = 0;
X_grad = zeros(size(X));
Theta_grad = zeros(size(Theta));

% ====================== YOUR CODE HERE ======================
% Instructions: Compute the cost function and gradient for collaborative
%               filtering. Concretely, you should first implement the cost
%               function (without regularization) and make sure it is
%               matches our costs. After that, you should implement the 
%               gradient and use the checkCostFunction routine to check
%               that the gradient is correct. Finally, you should implement
%               regularization.
%
% Notes: X - num_movies  x num_features matrix of movie features
%        Theta - num_users  x num_features matrix of user features
%        Y - num_movies x num_users matrix of user ratings of movies
%        R - num_movies x num_users matrix, where R(i, j) = 1 if the 
%            i-th movie was rated by the j-th user
%
% You should set the following variables correctly:
%
%        X_grad - num_movies x num_features matrix, containing the 
%                 partial derivatives w.r.t. to each element of X
%        Theta_grad - num_users x num_features matrix, containing the 
%                     partial derivatives w.r.t. to each element of Theta
%

t1 = X*Theta&#39;;
t1 = t1 - Y;
t1 = t1.^2;
J = sum(sum(R.*t1)) / 2;
% with regularization J
J = J + lambda / 2 * ( sum( sum (Theta.^2) )  + sum( sum (X.^2) ));
X_grad = R.*(X*Theta&#39; - Y) * Theta;
Theta_grad = (R.*(X*Theta&#39; - Y))&#39; * X;
% with regularization   
X_grad = X_grad + lambda * X;
Theta_grad = Theta_grad + lambda * Theta;
% =============================================================
grad = [X_grad(:); Theta_grad(:)];

end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ex7.K-means Clustering and Principal Component Analysis</title>
      <link>https://shiweihou.github.io/machinelearning/ex7/</link>
      <pubDate>Tue, 29 Nov 2016 11:18:44 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/machinelearning/ex7/</guid>
      <description>

&lt;p&gt;这节课主要讲了非监督学习的两个：K-means 和 Principal Component Analysis。K-means算法思想很简单，就是给你一堆数据，你需要在这无序的数据中将类似的数据聚合起来，分成K类，具体要分几类，可以通过 Elbow method （肘部法则）或者根据实际需求来确定。PCA算法通俗意义来讲，是降维操作。如果有个数据特征维数很大，例如100000维，其实在这么多的特种中，很多特征都是由相互联系的，通过PCA算法，就可以将原来维数很大数据特征，降低到我们容易进行处理的维数。&lt;/p&gt;

&lt;p&gt;PCA有几个好处： 降低存储容量，通过降维，提高学习算法运行速度。特别的，通过降维到2D或者3D，我们可以显示的观察特征，利于处理。但是如果想要通过PCA去降维来避免学习算法的过拟合问题，是不推荐的，或者不可取的。&lt;/p&gt;

&lt;h2 id=&#34;findclosestcentroids-m&#34;&gt;findClosestCentroids.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;m = size(X,1);
for i = 1 : m
    %二维数组，第i行用X(i,:)表示，不是X(i)
    dis = sum((X(i,:) - centroids(1,:)).^2);
    idx(i) = 1;
    for k = 1 : K
        dis2 = sum((X(i,:) - centroids(k,:)).^2);
        if  dis &amp;gt;= dis2
            dis = dis2;
            idx(i) = k;
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;computecentroids-m&#34;&gt;computeCentroids.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;for k = 1 : K
    centroid = zeros(1,n);
    Ck = 0;
    for i = 1 : m
        if idx(i) == k
            centroid = centroid + X(i,:);
            Ck = Ck + 1;
        end
    end
    centroid = centroid / Ck;
    centroids(k,:) = centroid;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kmeansinitcentroids-m&#34;&gt;kMeansInitCentroids.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;randidx = randperm(size(X,1));
centroids = X(randidx(1:K),:);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pca-m&#34;&gt;pca.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;eigenvector = X&#39;* X / m;
[U,S,~] = svd(eigenvector);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;projectdata-m&#34;&gt;projectData.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;U_reduce = U(:,1:K);
Z = X * U_reduce;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;recoverdata-m&#34;&gt;recoverData.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;X_rec = Z * U(:,1:K)&#39;;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ex6.Support Vector Machines</title>
      <link>https://shiweihou.github.io/machinelearning/ex6/</link>
      <pubDate>Fri, 25 Nov 2016 20:52:54 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/machinelearning/ex6/</guid>
      <description>

&lt;p&gt;这节讲到了SVM，Andrew Ng大神主要简单介绍了下核函数和SVM一些参数的影响。因为Ng大牛介绍的比较简单，所以看完自己又去网上百度了下，系统了了解了下。拙见就不在这发了，大家有兴趣的可以自己去百度。其实SVM就是个分类器，利用特定的核函数将在原空间维度线性不可分问题映射到高维，使之变成线性可分。另外学习这节课的时候又对偏差和方差有点迷，在知乎上找到一篇答案，比较优秀，链接在此：&lt;a href=&#34;https://www.zhihu.com/question/27068705&#34;&gt;机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)有什么区别和联系？&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;gaussian-kernel&#34;&gt;Gaussian Kernel&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%很简单，就是按照公式计算高斯核内积，难度0
sim = -sum( (x1 - x2).^2 ) /  2 / sigma^2;
sim = exp(sim);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dataset3params-m&#34;&gt;dataset3Params.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%选择出最好的一对 C sigma
C_final = C;
sigma_final = sigma;
min_error = size(yval,1);
% C 和 sigma 所有的可能
para = [0.01 0.03 0.1 0.3 1 3 10 30];
m = size(para,2);
% 将 C 和 sigma 所有的可能都训练测试一遍，找到效果最好的那对
for i = 1 : m
    for j = 1 : m
        C = para(i);
        sigma = para(j);
        model = svmTrain(X, y, C, @(x1, x2) gaussianKernel(x1, x2, sigma));
        pre = svmPredict(model,Xval);
        cur_error = mean(double(pre ~= yval));
        if cur_error &amp;lt; min_error
            min_error = cur_error;
            C_final = C;
            sigma_final = sigma;
        end
    end
end
C = C_final;
sigma = sigma_final;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;processemail-m&#34;&gt;processEmail.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%就是找到单词出现的下标位置，然后已列向量存储下来
for i = 1 : length(vocabList)
    if strcmp(str, vocabList{i}) == 1
        word_indices = [word_indices ; i];
        break;
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;emailfeatures-m&#34;&gt;emailFeatures.m&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%这个就更简单了，简单的说就是将所有出现的单词所在的下标位置，赋值1
for i = 1 : size(word_indices,1)
    x(word_indices(i)) = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在已经学习到第七周了，发现越高深的算法，其实实现起来越简单，因为现有的函数库都将其实质内容都包含隐藏起来了，你只需要实现相应的输入参数就可以了。说明发明一个算法是最难的，但学会用一个算法，就太简单了。
另在原有的代码有一个小bug，就是没办法显示Example Dataset 2的边界线，是visualizeBoundary.m出了点问题，课程助教也给了解决方法，及时将原有的&lt;code&gt;contour(X1, X2, vals, [0 0], &#39;Color&#39;, &#39;b&#39;);&lt;/code&gt;改为&lt;code&gt;contour(X1, X2, vals, [1 1], &#39;b&#39;);&lt;/code&gt;就可以了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>