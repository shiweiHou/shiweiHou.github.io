<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lintcodes on Hello world!</title>
    <link>https://shiweiHou.github.io/lintcode/</link>
    <description>Recent content in Lintcodes on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 24 Feb 2017 21:34:34 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/lintcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>leetcode 401.Binary Watch</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-401/</link>
      <pubDate>Fri, 24 Feb 2017 21:34:34 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-401/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; readBinaryWatch(int num) {
            int h[] = {1, 2, 4, 8};
            int m[] = {1, 2, 4, 8, 16,32};
            if (num &amp;gt; 10) num = 10;
            vector&lt;string&gt; ret;
            if (num == 0) { ret.push&lt;em&gt;back(&amp;ldquo;0:00&amp;rdquo;); return ret;}
            // 限制条件老是写错，出了一大堆的bug，烦烦烦烦烦烦
            for (int i = 0; i &amp;lt; 4 &amp;amp;&amp;amp; i &amp;lt;= num; ++i) {
                int j = num - i;
                if (j &amp;gt; 5) continue;
                // i, j is all possible num
                vector&lt;string&gt; hours;
                vector&lt;string&gt; minutes;
                // find hours
                find&lt;/em&gt;(hours, h, 0, 0, 0, i);
                // find minutes
                find_2(minutes, m, 0, 0, 0, j);
                if (hours.empty() &amp;amp;&amp;amp; !minutes.empty()){
                    for(auto min : minutes) {
                        ret.push_back(&amp;ldquo;0:&amp;rdquo; + min);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; minutes.empty()){
                    for (auto hour : hours) {
                        ret.push_back(hour + &amp;ldquo;:00&amp;rdquo;);
                    }
                } else if (!hours.empty() &amp;amp;&amp;amp; !minutes.empty()) {
                    for (auto hour : hours){
                        for (auto min : minutes) {
                            ret.push_back(hour + &amp;ldquo;:&amp;rdquo; + min);
                        }
                    }
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            hours.clear();
            minutes.clear();

        }

        return ret;
    }
    // cur 表示当前用了几个数，sum表示当前的和，pos表示搜索到的下标位置，all表示一共要选取几个数
    void find_(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 4 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 12) {
            vs.push_back(to_string(sum));
        }
        if (sum &amp;gt;= 12) return;
        find_(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_(vs, h, cur, sum, pos + 1, all);
    }
    void find_2(vector&amp;lt;string&amp;gt; &amp;amp;vs, int h[], int cur, int sum, int pos, int all) {
        if (pos &amp;gt;= 6 || cur &amp;gt; all) return;
        sum += h[pos];
        ++cur;
        if (cur == all &amp;amp;&amp;amp; sum &amp;lt; 60) {
            if (sum &amp;gt;= 10){
               vs.push_back(to_string(sum)); 
            } else {
                vs.push_back(&amp;quot;0&amp;quot; + to_string(sum));
            }
        }
        if (sum &amp;gt;= 60) return;
        find_2(vs, h, cur, sum, pos + 1, all);
        sum -= h[pos];
        --cur;
        find_2(vs, h, cur, sum, pos + 1, all);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 409.Longest Palindrome</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-409/</link>
      <pubDate>Fri, 24 Feb 2017 21:32:25 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-409/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int longestPalindrome(string s) {
            vector&lt;int&gt; vc(60, 0);
            int i = 0;
            while (i &amp;lt; s.size()) {
                ++vc[s[i]-&amp;lsquo;A&amp;rsquo;];
                ++i;
            }
            i = 0;
            int len = 0;
            while (i &amp;lt; 60) {
                if (vc[i] != 0 &amp;amp;&amp;amp; vc[i] % 2 == 0) {
                    len += vc[i];
                    vc[i] = 0;
                }
    // 一开始想错了，以为是奇数个的，只能用最多的那个奇数，其实所有出现次数大于1的奇数，都可以通过减1变成偶数个从而加入最长回文串内
                if (vc[i] % 2 == 1 &amp;amp;&amp;amp; vc[i] &amp;gt; 1) {
                    len += vc[i] - 1;
                    vc[i] = 1;
                }
                ++i;
            }
            i = 0; // 所有的遍历完之后，发现还有有的数还有一次机会，那就放到最中间去，len++，变成最长回文串
            while (i &amp;lt; 60) {
                if (vc[i] != 0) {
                    ++len;
                    break;
                }
                ++i;
            }
            return len ;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 453.Minimum Moves to Equal Array Elements</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-453/</link>
      <pubDate>Fri, 24 Feb 2017 21:28:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-453/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int minMoves(vector&lt;int&gt;&amp;amp; nums) {
            // 假设经过M次移动后，所有的数为同一个值，为X，原先数组的和为SUM，最小值为minNum,则此时有公式
            // sum + M * (n - 1) = X * n;
            // 而 X 其实是等于最小的那个数加了M次 X = minNum + M
            // 带入化简，得到 M = sum - minNum * n;
            int sum = 0;
            int minNum = nums[0];
            int i = 0;
            while (i &amp;lt; nums.size()) {
                sum += nums[i];
                minNum = min(minNum, nums[i]);
                ++i;
            }
            return sum - minNum * nums.size();
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 476.Number Complement</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-476/</link>
      <pubDate>Fri, 24 Feb 2017 21:26:30 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-476/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        int findComplement(int num) {
            // 这个是最笨的一种方法，就是首先将num右移，查看num去除前缀0之后有效位有几位
            // 然后再重新遍历一边num的末尾数字，根据有效位的个数控制右移几次，还利用了pow函数
            // 网上有一种最简单的，其实上面的那种方法，也是根据后几位来求，假如后4位为有效位
            // 那么我们如果能得到一个 后四位为0前面几位都为1的数，和num进行分别取反进行&amp;amp;操作就可以
            // mask = ~0;
            // while (mask &amp;amp; num) mask = mask &amp;lt;&amp;lt; 1;
            // return ~num &amp;amp; ~mask
            // 例如            num =  0000 0101
            // 经过while循环， mask = 1111 1000
            // ~num &amp;amp; ~mask = 0000 0010 = 2
            int n = 0;
            int num1 = num;
            while (num1) {
                ++n;
                num1 = num1 &amp;gt;&amp;gt; 1;
            }
            int ret = 0, i = 0;
            while(i &amp;lt; n) {
                int a = num &amp;amp; 1;
                ret += (a == 1? 0 : 1) * pow(2,i);
                ++i;
                num = num &amp;gt;&amp;gt; 1;
            }
            return ret;
        }
    };&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 506.Relative Ranks</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-506/</link>
      <pubDate>Fri, 24 Feb 2017 21:20:31 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-506/</guid>
      <description>&lt;p&gt;class Solution {
    public:
        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp;amp; nums) {
            // 先求出最大值，然后遍历查询比当前数大的数有几个
            // 多此一举了，不需要求最大值，直接遍历就行，还是想的多了
            int max_num = nums[0];
            int i = 1;
            while (i &amp;lt; nums.size()) {
                max_num = max(max_num, nums[i]);
                ++i;
            }
            i = 0;
            vector&lt;string&gt; ret;
            while (i &amp;lt; nums.size()) {
                nums[i] = max_num - nums[i];
                ++i;
            }
            i = 0;
            while (i &amp;lt; nums.size()) {
                int count = order(nums, i);
                if (count == 0) ret.push_back(&amp;ldquo;Gold Medal&amp;rdquo;);
                else if (count == 1) ret.push_back(&amp;ldquo;Silver Medal&amp;rdquo;);
                else if (count == 2) ret.push_back(&amp;ldquo;Bronze Medal&amp;rdquo;);
                else ret.push_back(to_string(count + 1));
                ++i;
            }
            return ret;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    int order(vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos) {
        int count = 0;
        int i = 0;
        while (i &amp;lt; nums.size()) {
            if (i != pos &amp;amp;&amp;amp; nums[pos] &amp;gt; nums[i]) ++count;
            ++i;
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 12 &amp; 13 </title>
      <link>https://shiweihou.github.io/lintcode/leetcode-12/</link>
      <pubDate>Fri, 24 Feb 2017 21:16:03 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-12/</guid>
      <description>&lt;p&gt;数字转换为罗马数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string intToRoman(int num) {
        string M[] = {&amp;quot;&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;MM&amp;quot;, &amp;quot;MMM&amp;quot;};//0 1000 2000 3000
        string C[] = {&amp;quot;&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;CC&amp;quot;, &amp;quot;CCC&amp;quot;, &amp;quot;CD&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;DC&amp;quot;, &amp;quot;DCC&amp;quot;, &amp;quot;DCCC&amp;quot;, &amp;quot;CM&amp;quot;};// 0 100 200 300 400 500 600 700 800 900
        string X[] = {&amp;quot;&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;XX&amp;quot;, &amp;quot;XXX&amp;quot;, &amp;quot;XL&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;LX&amp;quot;, &amp;quot;LXX&amp;quot;, &amp;quot;LXXX&amp;quot;, &amp;quot;XC&amp;quot;};// 0 10 20 30 40 50 60 70 80 90
        string I[] = {&amp;quot;&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;II&amp;quot;, &amp;quot;III&amp;quot;, &amp;quot;IV&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;VI&amp;quot;, &amp;quot;VII&amp;quot;, &amp;quot;VIII&amp;quot;, &amp;quot;IX&amp;quot;};// 0 1 2 3 4 5 6 7 8 9

        return M[num / 1000] + C[num % 1000 / 100] + X[num % 100 / 10] + I[num % 10];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;罗马数字转换为数字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int romanToInt(string s) {
        unordered_map&amp;lt;char, int&amp;gt; T = { { &#39;I&#39; , 1 },
                                    { &#39;V&#39; , 5 },
                                   { &#39;X&#39; , 10 },
                                   { &#39;L&#39; , 50 },
                                   { &#39;C&#39; , 100 },
                                   { &#39;D&#39; , 500 },
                                   { &#39;M&#39; , 1000 } };

        int sum = T[s.back()];
        for (int i = s.length() - 2; i &amp;gt;= 0; --i) 
        {
            // 根据罗马数字左减右加原则
            if (T[s[i]] &amp;lt; T[s[i + 1]])
            {
                sum -= T[s[i]];
            }
            else
            {
                sum += T[s[i]];
            }
        }

        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>leetcode 461.Hamming Distance</title>
      <link>https://shiweihou.github.io/lintcode/leetcode-461/</link>
      <pubDate>Fri, 24 Feb 2017 21:04:46 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/leetcode-461/</guid>
      <description>&lt;p&gt;题目要求求出两个非负数之间二进制对应位不同值是多少，例如1对应二进制为 0 0 0 1（后四位），4对应二进制为 0 1 0 0，那么不同值就是2，从右往前看是第1位与第三位不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int hammingDistance(int x, int y) {
        int count = 0;
        // 最朴素的一种做法，就是每次求得两个数的最后一个比特位，然后比较，然后两个数右移
        while (x || y) { // 当x和y全部为0时才退出循环
            int a = x &amp;amp; 1; // 找到x和y二进制最后一位的数到底时0还是1
            int b = y &amp;amp; 1;
            if (a != b) ++count;
            x = x &amp;gt;&amp;gt; 1; // x右移一位
            y = y &amp;gt;&amp;gt; 1; // y右移一位
        }
        // 还有一种更简单的做法，就是将x^y的值求出来，求结果中有多少个1，那么就是答案
        // count = 0;
        // int n = x ^ y;
        // while (n) {
        //    ++count;
        //    n &amp;amp;= n - 1;
        // }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 表达树构造</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-03/</link>
      <pubDate>Sun, 25 Dec 2016 16:47:22 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-03/</guid>
      <description>&lt;p&gt;看到这个题目就感觉和前两天做的“逆波兰表达式”很像，想的方法就是先将表达式转化成逆波兰表达式，因为逆波兰表达式就是后缀表达式，维护一个栈，从头开始遍历后缀表达式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;碰到数值，就生成个结点，然后将结点指针放入栈中&lt;/li&gt;
&lt;li&gt;碰到操作数，就在栈中弹出两个指针作为该操作数的右左子树，接着将指向操作数的指针入栈&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到最后栈中就只会剩下根节点了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition of ExpressionTreeNode:
 * class ExpressionTreeNode {
 * public:
 *     string symbol;
 *     ExpressionTreeNode *left, *right;
 *     ExpressionTreeNode(string symbol) {
 *         this-&amp;gt;symbol = symbol;
 *         this-&amp;gt;left = this-&amp;gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param expression: A string array
     * @return: The root of expression tree
     */
    ExpressionTreeNode* build(vector&amp;lt;string&amp;gt; &amp;amp;expression) {
        // write your code here
        // 首先将表达式转换为逆波兰表达式，也就是表达树的后缀表示形式
        vector&amp;lt;string&amp;gt; nibolan;
        stack&amp;lt;string&amp;gt; operat;
        operat.push(&amp;quot;@&amp;quot;);
        int i = 0;
        while ( i &amp;lt; expression.size()) {
            string s = expression[i];
            if (s != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;/&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;(&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;)&amp;quot;) {
                nibolan.push_back(s);

        } else if ( s == &amp;quot;(&amp;quot;) {
            operat.push(s);

        } else if ( s == &amp;quot;)&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.pop();
        } else if ( s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot;) {
            string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; (top == &amp;quot;*&amp;quot; || top == &amp;quot;/&amp;quot;) ) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s);
        } else {
           string top = operat.top();
            while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                nibolan.push_back(top);
                operat.pop();
                top = operat.top();
            }
            operat.push(s); 
        }
        ++i;
    }
    string top = operat.top();
    while (top != &amp;quot;@&amp;quot; ) {
        nibolan.push_back(top);
        operat.pop();
        top = operat.top();
    }
    //从前往后，根据后缀表达式构建表达树,维护一个栈，栈中存放着树的指针，如果是操作符，就从栈中弹出两个指针作为它的右左子树，如果是数字，就直接入栈，最后栈中只会留下根指针
    stack&amp;lt;ExpressionTreeNode*&amp;gt; st;
    i = 0;
    while (i &amp;lt; nibolan.size()) {
        string s = nibolan[i];
        ExpressionTreeNode * node = new ExpressionTreeNode (s);
        if (s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot; || s == &amp;quot;+&amp;quot; || s == &amp;quot;-&amp;quot;) {
            ExpressionTreeNode* right = st.top();
            st.pop();
            ExpressionTreeNode* left = st.top();
            st.pop();
            node-&amp;gt;left = left;
            node-&amp;gt;right = right;
        }
        st.push(node);
        ++i;
    }
    if (st.empty()) return NULL;
    return st.top();

}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 用栈模拟汉诺塔问题</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-02/</link>
      <pubDate>Sun, 25 Dec 2016 16:41:24 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-02/</guid>
      <description>&lt;p&gt;我们知道汉诺塔问题是个经典的递归问题，思路就是有三根柱子 A B C，将N个按大小排好的碟子从A移动到C上，每次只移动一个并且只能将小的放在大的上面。将N-1个碟子利用柱子B从A放在B上，再将第N个碟子从A移动到C上，然后将剩下的N-1个碟子从B再移动到A上，重复这个过程，直到所有的碟子都移动完毕。根据Lintcode提供的接口，我们只需要补充完整就好了，在做的过程中也遇到了一些小问题，在代码里都注释了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Tower {
public:
    // create three towers (i from 0 to 2)
    Tower(int i) {}

    // Add a disk into this tower
    void add(int d) {
        if (!disks.empty() &amp;amp;&amp;amp; disks.top() &amp;lt;= d) {
            printf(&amp;quot;Error placing disk %d&amp;quot;, d);
        } else {
            disks.push(d);
        }
    }

    // @param t a tower
    // Move the top disk of this tower to the top of t.
    void moveTopTo(Tower &amp;amp;t) {
        // Write your code here
        //不明白加上这句if (disks.top() &amp;gt; t.disks.top())为什么错误
        //1是没有考虑到disks是private，不能直接由对象调用，2是没有判断t的disnks是不是空的，所以才出错
        //if (disks.top() &amp;gt; t.disks.top()) ;
        stack&amp;lt;int&amp;gt; s = t.getDisks();
        if (!s.empty() &amp;amp;&amp;amp; disks.top() &amp;gt; s.top()) ;
        t.add(disks.top());
        disks.pop();

    }

    // @param n an integer
    // @param destination a tower
    // @param buffer a tower
    // Move n Disks from this tower to destination by buffer tower
    void moveDisks(int n, Tower &amp;amp;destination, Tower &amp;amp;buffer) {
        // Write your code here
        if (n == 0) return ;
        else if (n == 1) moveTopTo(destination);
        else {
            moveDisks(n-1,buffer,destination);
            moveTopTo(destination);
            buffer.moveDisks(n-1,destination,*this);
        }

    }

    stack&amp;lt;int&amp;gt; getDisks() {
        return disks;
    }

private:
    stack&amp;lt;int&amp;gt; disks;
};
/**
 * Your Tower object will be instantiated and called as such:
 * vector&amp;lt;Tower&amp;gt; towers;
 * for (int i = 0; i &amp;lt; 3; i++) towers.push_back(Tower(i));
 * for (int i = n - 1; i &amp;gt;= 0; i--) towers[0].add(i);
 * towers[0].moveDisks(n, towers[2], towers[1]);
 * print towers[0], towers[1], towers[2]
*/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lintcode 矩阵的之字型遍历</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-25-01/</link>
      <pubDate>Sun, 25 Dec 2016 16:33:35 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-25-01/</guid>
      <description>&lt;p&gt;题目要求：给一个矩阵，按照之字型进行遍历，&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/matrix-zigzag-traversal/&#34;&gt;题目链接&lt;/a&gt;
思路：其实仔细想一想，就是先斜着往下遍历，再斜着往上遍历，就是这个过程，主要是判断好临界条件，是要往右走还是往下走
代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param matrix: a matrix of integers
     * @return: a vector of integers
     */
    vector&amp;lt;int&amp;gt; printZMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix) {
        // write your code here
        int row = matrix.size();
        int col = matrix[0].size();
        vector&amp;lt;int&amp;gt; ret (row * col, 0);
        int r = 0;
        int c = 0;
        int i = 0;
        int all = row * col;
        ret[i++] = matrix[0][0];
        while (i &amp;lt; all) {
            // 斜上走到顶
            while (i &amp;lt; all &amp;amp;&amp;amp; r - 1 &amp;gt;= 0 &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[--r][++c];
            }
            // 横右走一步，不可横右走时竖下走一步
            if (i &amp;lt; all &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[r][++c];
            } else if (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row) {
                ret[i++] = matrix[++r][c];
            }
            // 斜下走到底
            while (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row &amp;amp;&amp;amp; c - 1 &amp;gt;= 0) {
                ret[i++] = matrix[++r][--c];
            }
            // 竖下走一步，不可竖下时横右走一步
            if (i &amp;lt; all &amp;amp;&amp;amp; r + 1 &amp;lt; row) {
                ret[i++] = matrix[++r][c];
            } else if (i &amp;lt; all &amp;amp;&amp;amp; c + 1 &amp;lt; col) {
                ret[i++] = matrix[r][++c];
            }
        }
        return ret;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 将表达式转换为逆波兰表达式</title>
      <link>https://shiweihou.github.io/lintcode/2016-12-22-01/</link>
      <pubDate>Thu, 22 Dec 2016 20:55:54 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-12-22-01/</guid>
      <description>&lt;p&gt;问题描述：
    给定一个表达式字符串数组，返回该表达式的逆波兰表达式。&lt;/p&gt;

&lt;p&gt;问题分析：首先要搞明白什么是逆波兰表达式，&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&#34;&gt;wiki&lt;/a&gt;上面有很详细的介绍，题目意思就是将我们平常习惯的数学表达式表示成计算机所能理解的式子。因为人类可以很自然的理解例如&lt;code&gt;1 + 2 * 3&lt;/code&gt;这样的式子，但计算机没有办法，计算机需要将其转换为&lt;code&gt;123*+&lt;/code&gt;这样的形式才可以。&lt;/p&gt;

&lt;p&gt;前面有一道题是将逆波兰表达式转换为中缀表达式，这道题刚好反过来。其实如果我们首先先自己在草稿纸上自己将中缀表达式转为逆波兰表达式的过程演算一遍，就很自然的明白转换规则：假设我们有一个&lt;code&gt;vector ret&lt;/code&gt;用来专门存答案，有一个&lt;code&gt;stack opera&lt;/code&gt;用来存操作符（&lt;code&gt;+ - * / （&lt;/code&gt;） ），另字符串&lt;code&gt;ch&lt;/code&gt;为表达式&lt;code&gt;expression&lt;/code&gt;中的元素，规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;假如&lt;code&gt;ch&lt;/code&gt;为数字，那么很自然的，将其放入&lt;code&gt;ret&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;假如&lt;code&gt;ch&lt;/code&gt;为操作符，那么：

&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch == &amp;quot;(&amp;quot;&lt;/code&gt;,那么将&lt;code&gt;ch&lt;/code&gt;放入到&lt;code&gt;opera&lt;/code&gt;中；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch == &amp;quot;)&amp;quot;&lt;/code&gt;,那么将&lt;code&gt;opera&lt;/code&gt;中最顶层的&lt;code&gt;（&lt;/code&gt;上面的所有操作符放入&lt;code&gt;ret&lt;/code&gt;中&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果&lt;code&gt;ch
是四则运算符&lt;/code&gt;,那么根据此时&lt;code&gt;opera&lt;/code&gt;中已有的字符的优先级，如果&lt;code&gt;ch&lt;/code&gt;大于此时&lt;code&gt;opera&lt;/code&gt;顶层操作符的优先级，那么&lt;code&gt;ch&lt;/code&gt;放入到&lt;code&gt;opera&lt;/code&gt;中，如果不是，那么将&lt;code&gt;opera&lt;/code&gt;中的运算符弹出放入&lt;code&gt;ret&lt;/code&gt;中，直到碰到第一个大于&lt;code&gt;ch&lt;/code&gt;的优先级的运算符或者碰到第一个&lt;code&gt;（&lt;/code&gt;或者走到头。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们首先放进去一个字符@，表示优先级最低或者表示栈底
代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param expression: A string array
     * @return: The Reverse Polish notation of this expression
     */
    vector&amp;lt;string&amp;gt; convertToRPN(vector&amp;lt;string&amp;gt; &amp;amp;expression) {
        // write your code here
        vector&amp;lt;string&amp;gt; nibolan;
        stack&amp;lt;string&amp;gt; operat;
        operat.push(&amp;quot;@&amp;quot;);
        int i = 0;
        while ( i &amp;lt; expression.size()) {
            string s = expression[i];
            if (s != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;/&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;(&amp;quot; &amp;amp;&amp;amp; s != &amp;quot;)&amp;quot;) {
                nibolan.push_back(s);

            } else if ( s == &amp;quot;(&amp;quot;) {
                operat.push(s);

            } else if ( s == &amp;quot;)&amp;quot;) {
                string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.pop();
            } else if ( s == &amp;quot;*&amp;quot; || s == &amp;quot;/&amp;quot;) {
                string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; (top == &amp;quot;*&amp;quot; || top == &amp;quot;/&amp;quot;) ) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.push(s);
            } else {
               string top = operat.top();
                while (top != &amp;quot;@&amp;quot; &amp;amp;&amp;amp; top != &amp;quot;(&amp;quot;) {
                    nibolan.push_back(top);
                    operat.pop();
                    top = operat.top();
                }
                operat.push(s); 
            }
            ++i;
        }
        string top = operat.top();
        while (top != &amp;quot;@&amp;quot; ) {
            nibolan.push_back(top);
            operat.pop();
            top = operat.top();
        }

        return nibolan;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 分糖果</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-31-01/</link>
      <pubDate>Mon, 31 Oct 2016 20:01:12 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-31-01/</guid>
      <description>&lt;p&gt;题目链接：&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/candy/&#34;&gt;分糖果&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始想的先排序，然后从低到高遍历，定义一个rat和pre，rat保存当前需要加的糖果数，pre为上一个rating，如果当前ratings[i] == pre， 就将rat置为1，不是就将rat++。。。。。后来发现不是这么做的，因为测试数据怎么都过不了。&lt;/p&gt;

&lt;p&gt;首先，不能排序！不能改变原有的顺序！题目的意思应该理解为“ 当前rating如果比其左右都高的话，其糖果个数不应该小于其左右的糖果个数”。 所以需要遍历两次，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先从左到右遍历一次，保证当右边的rating大于其左边的rating值时，糖果个数不小于左边的糖果值&lt;/li&gt;
&lt;li&gt;然后从右往左再遍历一次，保证当左边的rating大于其右边的rating值时，糖果个数不小于右边的糖果值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后所有的加起来就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param ratings Children&#39;s ratings
     * @return the minimum candies you must give
     */
    int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) {
        // Write your code here
        int sum = 0;
        int len = ratings.size();
        int *num = new int[len];

        num[0] = 1;
        // 从左往右
        for (int i = 1; i &amp;lt; len; ++i) {
            num[i] = ratings[i] &amp;gt; ratings[i-1] ? num[i-1] + 1 : 1;
        }
        //从右往左
        for (int i = len - 1; i &amp;gt; 0; --i) {
            num[i - 1] = ratings[i] &amp;lt; ratings[i-1] ? max(num[i] + 1, num[i - 1]) : num[i - 1];
        }
        for (int i = 0; i &amp;lt; len; ++i) sum += num[i];

        delete []num;
        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;，&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 二进制表示</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-13-02/</link>
      <pubDate>Thu, 13 Oct 2016 20:46:54 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-13-02/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/binary-representation/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说是困难题，其实很简单的，就是将字符串中整数部分和小数部分分别提取出来，然后根据整数化二进制和小数划二进制的形式来求。唯一有问题的就是字符串中的小数部分化成小数时，如果按照传统的一个个来做的话，在计算机中表示很奇怪，例如对于&lt;code&gt;4096.6435546875&lt;/code&gt;，小数部分按照6*10（-1） + 4*10（-2）&amp;hellip;这样求的话，在计算机中实际表示为&lt;code&gt;0.64355468750000011&lt;/code&gt;，所以很奇怪，估计是和计算机中浮点型的存储方式有关，所以后来就直接用C++自带的库函数&lt;code&gt;atof()&lt;/code&gt;函数来转换，这样就ok了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
/**
 *@param n: Given a decimal number that is passed in as a string
 *@return: A string
 */
string binaryRepresentation(string n) {
    // wirte your code here
    string ret;
    if (n.empty()) return 0;
    int len = n.size();
    int i = 0;
    while (i &amp;lt; len &amp;amp;&amp;amp; n[i] != &#39;.&#39;) ++i;
    int j = 0;
    bool flag = true;
    if (n[0] == &#39;-&#39;) {
        flag = false;
        ++j;
        ret += &amp;quot;1&amp;quot;;
    }

    long number = 0;
    while (j &amp;lt; i) {
        number = number * 10 + (n[j] - &#39;0&#39;);
        ++j;
    }
    longToBinary(number, ret);

    if (i == len) return ret;
    ret += &amp;quot;.&amp;quot;;


    double number1 = 0.0;
    ++i;
    int count = -1;
    while (i &amp;lt; len) {
        number1 += (n[i] - &#39;0&#39;) * (double)pow(10, count);
        ++i;
        --count;
    }

    bool yes = true;
    // 自己计算的不行，还得靠库函数
    double decPart = atof(n.substr(n.find(&amp;quot;.&amp;quot;), n.size() - n.find(&amp;quot;.&amp;quot;)).c_str());
    number1 = decPart;
    yes = digitToBinary(number1, ret);

    int len1 = ret.size();
    if (ret[len1-1] == &#39;.&#39;) ret = ret.substr(0,len1-1);
    if (yes) return ret;
    ret = &amp;quot;ERROR&amp;quot;;
    return ret;
}

bool digitToBinary(double number, string &amp;amp;s) {
    int time = 0;
    double number1 = 1.0;
    double number2 = 0.0;
    while (time &amp;lt;= 32) {
        if (number == number1) 
            break;
        if (number == number2) 
            break;
        number *= 2;
        if (number &amp;gt;= 1) {
            number -= 1.0;
            s += to_string(1);
        } else s += to_string(0);

        ++time;
    }

    if (time &amp;lt;= 32) return true;
    return false;
}
void longToBinary(long number, string &amp;amp;s) {
    vector&amp;lt;int&amp;gt; vb;
    while (number != 0) {
        vb.push_back(number % 2) ;
        number /= 2;
    }
    if (vb.empty()) {
        s += to_string(0);
        return;
    }
    reverse(vb.begin(), vb.end());
    for (auto e : vb) {
        s += to_string(e);
    }

    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> LintCode 逆波兰表达式求值</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-13-01/</link>
      <pubDate>Thu, 13 Oct 2016 20:43:48 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-13-01/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/evaluate-reverse-polish-notation/&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;题意很明确，其实就是四则运算的后缀求值，用栈来维护，中间过程中没有考虑栈元素不够或者除数为0的情况，但也AC了，说明输入的数据比较严格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) {
    // Write your code here
    stack&amp;lt;int&amp;gt; s;
    int ans;
    if (tokens.empty()) return ans;
    for (auto e : tokens) {
        if (e != &amp;quot;+&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;-&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;*&amp;quot; &amp;amp;&amp;amp; e != &amp;quot;/&amp;quot;) {
            int number = stoi(e);
            s.push(number);
            continue;
        } 
        int x = s.top();
        s.pop();
        int y = s.top();
        s.pop();
        if (e == &amp;quot;+&amp;quot;) s.push(x + y);
        if (e == &amp;quot;-&amp;quot;) s.push(y - x);
        if (e == &amp;quot;/&amp;quot;) s.push(y / x);
        if (e == &amp;quot;*&amp;quot;) s.push(x * y);
    }

    return s.top();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 买卖股票的最佳时机（1 2 3 4）</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-11-01/</link>
      <pubDate>Tue, 11 Oct 2016 20:21:15 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-11-01/</guid>
      <description>

&lt;h2 id=&#34;买卖股票的最佳时机-1-1&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock/&#34;&gt;买卖股票的最佳时机&lt;/a&gt; 1&lt;/h2&gt;

&lt;p&gt;题目就不贴了，链接在上面&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;题意很简单，因为我们最多只可以完成一次交易，而且股票交易必须在前面买入才可以卖出，所以我们只需要从前往后遍历，维护两个变量值，minPrice表示所有的股票中价钱最低的那个，maxProfit表示到第i天所能获得的最大利润。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if (prices.empty()) return 0;

    int n = prices.size();Lint
    int minPrice = prices[0];
    int maxProfit = 0;

    for (int i = 1; i &amp;lt; n; ++i) {
    // 如果当前股票价格还要小于前面的已知的最低价格，就替换之，当然不需要进行卖出，相反还要买入
        if (minPrice &amp;gt; prices[i]) {
            minPrice = prices[i];
        } else  // 否则的话，在第i天使可以尝试卖出的，更新maxProfit
            maxProfit = max(maxProfit, prices[i] - minPrice);
    }

    return maxProfit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-ii-2&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-ii/&#34;&gt;买卖股票的最佳时机 II&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;最笨的一种方法。因为要尽可能的获得最大利润，当然是完成每次交易的获得的利润越大越好。因为我没有想到当天卖出再买入这件事，只是想到一天只能买入或者卖出，所以得到如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int sum = 0;
    if (prices.empty() || prices.size() &amp;lt; 2) return sum;

    int n = prices.size();

    int i = 1;
    // buy 记录买入股票的价钱
    int buy = prices[0];
    while ( i &amp;lt; n ) {
    // 如果当天的价格还在上涨，那就不卖出，继续往下看；如果不是，说明从buy的那一天到i-1天都是上涨的，那么就在第i-1天卖出，继续往下看。
        if (prices[i] &amp;gt; prices[i-1]) {
            ++i;
            if (i == n) sum += prices[i-1] - buy;
        }
        else {
            sum += prices[i-1] - buy;
            buy = prices[i];
            ++i;
        }
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网上还有一种更简单的算法，就是尽可能交易更多的次数，当天可以买也可以卖，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int sum = 0;
    if (prices.empty() || prices.size() &amp;lt; 2) return sum;

    int n = prices.size();
    for (int i = 1; i &amp;lt; n; ++i) {
    // 意思是只要当天卖可以有利润，就卖出去，再买回来，继续往后看
        if (prices[i] &amp;gt; prices[i-1])
            sum += prices[i] - prices[i-1];
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-iii-3&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-iii/&#34;&gt;买卖股票的最佳时机 III&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;因为是可以完成两笔交易，所以最最容易想到的办法就是对每个时间点i，分别计算1~i 和 i~n 所能获得的最大利润和。但这样时间复杂度为 O(n^2)。但是我们知道我们在计算1~i的最大利润的时候，1~i-1的利润已经计算过了，不需要再重新计算一遍，因此：&lt;strong&gt;保存两个数组，left[i], right[i],分别记录从左到右和从右往左分别到i位置所能产生的最大利润，最后直接遍历一遍两个数组就可以了，找出最大的left[i] + right[i] 组合，该解法实际上就是将 1 的解法双向各执行一遍记录结果&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;

    vector&amp;lt;int&amp;gt; left (prices.size(), 0);
    vector&amp;lt;int&amp;gt; right (prices.size(), 0);

    int leftMin = prices[0];
    int rightMax = prices[prices.size()-1];

    int sum = 0;
    //计算左半段最大收益
    for(int i = 1 ; i &amp;lt; prices.size(); ++i){
        leftMin = min(prices[i], leftMin);
        left[i] = max(prices[i] - leftMin, left[i-1]);
    }
    //计算右半段最大收益
    for(int i = prices.size() - 2 ; i &amp;gt;= 0; --i){
        rightMax = max(prices[i], rightMax);
        right[i] = max(rightMax - prices[i], right[i+1]);
    }
    //找出两次交易最大收益组合
    for(int i = 0 ; i &amp;lt; prices.size(); ++i){
        if( (left[i]+right[i]) &amp;gt; sum ) 
            sum = left[i] + right[i];
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在网上还看到一种解法，十分巧妙：其实我们并不需要知道每个时间点买卖第一第二笔股票收益的全部信息，我们只要知道前一个时间点买卖第一第二笔股票的最大收益信息，就可以直到当前最大的收益信息了，这样可以为我们省去额外空间。这里我们遍历prices数组的时候，维护四个变量:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;release2是在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第二笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;hold2是在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱，或者上一轮买入第二笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;release1是在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱，或者上一轮卖出第一笔股票后手里剩的钱两者中较大的。&lt;/li&gt;
&lt;li&gt;hold1是在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱或者初始资金（不买）中较大的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里计算顺序按照release2 -&amp;gt; hold2 -&amp;gt; release1 -&amp;gt; hold1，因为卖是要后于买的，而第二次交易也是后于第一次交易的，通过这个顺序我们能用这些变量自身来记录上次的值。相当于release2的时间点要先于hold1四个点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    int hold1 = INT_MIN, hold2 = INT_MIN;
    int release1 = 0, release2 = 0;
    int n = prices.size();
    for(int i = 0; i &amp;lt; n; ++i){
        // 在该价格点卖出第二笔股票后手里剩的钱，等于上一轮买入第二笔股票后手里剩的钱加上卖出当前股票价格的钱
        // 或者上一轮卖出第二笔股票后手里剩的钱两者中较大的
        release2 = max(release2, hold2 + prices[i]);
        // 在该价格点买入第二笔股票后手里剩的钱，等于上一轮卖出第一笔股票后手里剩的钱减去买入当前股票价格的钱
        // 或者上一轮买入第二笔股票后手里剩的钱两者中较大的
        hold2 = max(hold2, release1 - prices[i]);
        // 在该价格点卖出第一笔股票后手里剩的钱，等于上一轮买入第一笔股票后手里剩的钱加上卖出当前股票价格的钱
        // 或者上一轮卖出第一笔股票后手里剩的钱两者中较大的
        release1 = max(release1, hold1 + prices[i]);
        // 在该价格点买入第一笔股票后手里剩的钱，等于初始资金减去买入当前股票价格的钱
        // 或者初始资金（不买）中较大的
        hold1 = max(hold1, 0 - prices[i]);
    }
    return release2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;买卖股票的最佳时机-iv-4&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-iv/&#34;&gt;买卖股票的最佳时机 IV&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;我们将第 i 天已经执行 j 笔交易的最大收益作为全局变量 global[i][j], 将第 i 天正好完成第 j 笔交易的最大收益作为局部变量 local[i][j].&lt;/p&gt;

&lt;p&gt;也就是说， global[i][j] 就是我们最终要得到的结果，但 local[i][j] 的意思是，再第i天必须当天完成第j笔交易，而 global[i][j] 则不需要。&lt;/p&gt;

&lt;p&gt;对于 global[i][j], 也就是我们要知道的第i天已经完成j笔交易获得的最大收益，可以基于第 i-1 天完成 j 笔交易的最大收益与 第 i 天正好完成第 j 笔交易的最大收益，即 global[i][j] = max ( global[i-1][j], local[i][j] ).&lt;/p&gt;

&lt;p&gt;对于 local[i][j], 也就是我们要求的第i天刚好完成第j笔交易的最大收益，可以基于第i-1天正好完成第j-1笔交易的最大收益加上当天交易的差值， 还有第i-1天正好完成第j笔交易的最大收益加上当天交易的差值。 要注意的是，&lt;/p&gt;

&lt;p&gt;第i-1天正好完成第j-1笔交易的这种情况，当前交易的差值去0和实际昨天今天差价中较大的那个，因为如果我们还剩下1次交易机会，如果prices[i] &amp;gt; prices[i-1],我们完全可以在第i-1天完成第j-1笔交易后，再当天买入，第i天卖出。&lt;/p&gt;

&lt;p&gt;但是对于第i-1天正好完成第j笔交易这种情况，因为第i-1天正好完成第j笔交易，那么第i天的交易其实在第i-1天交易里面，也就是第i天要连着第i-1天交易，使得第i-1天完成的第j笔交易正好和第i天完成的第j笔交易是同一天交易，所以无论prices[i]是否大于prices[i-1], 这次交易都要进行下去，所以local[i][j] = max ( global[i-1][j-1] + max (diff, 0), local[i-1][j] + diff);diff = prices[i] - prices[i-1].&lt;/p&gt;

&lt;p&gt;PS:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于k &amp;gt; n /
2的情况，我们可以用II的解法来节省空间。因为按照题意必须先买后卖，那么对于n天交易，能够产生有效收益的交易次数是小于等于n/2的，只有不同天买卖才能产生差价。对于大于n/2的那部分交易，必定是当天买卖没有任何收益的，无论交易多少次都是一样的。所以如果k &amp;gt; n / 2，就相当于无限次交易。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方法理解了很简单，但真要自己写出来很难。我也没有写出来，还是参考的别人的答案才做出来，还需努力啊。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(int k, vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;
    //用II的解法优化k &amp;gt; n / 2的情况
    int n = prices.size();
    if(k &amp;gt; n / 2){
        int sum = 0;
        for(int i = 1; i &amp;lt; n; ++i){
            if(prices[i] &amp;gt; prices[i-1]) sum += prices[i] - prices[i-1];
        }
        return sum;
    }
    //初始化全局变量和局部变量
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; local(n+1, vector&amp;lt;int&amp;gt;(k+1, 0));
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; global(n+1, vector&amp;lt;int&amp;gt;(k+1, 0));

    for(int i = 1; i &amp;lt; n; ++i){
        int diff = prices[i] - prices[i-1];
        for(int j = 1; j &amp;lt; k + 1; ++j){
            //更新局部变量
            local[i][j] = max(global[i-1][j-1] + max(0, diff), local[i-1][j] + diff);
            //更新全局变量
            global[i][j] = max(global[i-1][j], local[i][j]);
        }
    }
    return global[n - 1][k];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种解法，类似于 ||| 中后一种解法一样，区别是我们这次要用 2K 个变量来记录 K 次交易。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxProfit(int k, vector&amp;lt;int&amp;gt; &amp;amp;prices) {
    // write your code here
    if(prices.empty()) return 0;
    //用II的解法优化k &amp;gt; n / 2的情况
    int n = prices.size();

    if(k &amp;gt; n / 2){
        int sum = 0;
        for(int i = 1; i &amp;lt; n; ++i){
            if(prices[i] &amp;gt; prices[i-1]) sum += prices[i] - prices[i-1];
        }
        return sum;
    }
    //初始化买卖股票后剩余金钱的数组
    vector&amp;lt;int&amp;gt; release (k + 1, 0);
    vector&amp;lt;int&amp;gt; hold    (k + 1, INT_MIN);


    for(int i = 0; i &amp;lt; n; i++){
        for(int j = 1; j &amp;lt; k+1; ++j){
            //卖出第j笔交易，所剩余的钱
            release[j] = max(release[j], hold[j] + prices[i]);
            //买入第j笔交易，所剩余的钱
            hold[j] = max(hold[j], release[j-1] - prices[i]);
        }
    }
    return release[k];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>