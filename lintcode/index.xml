<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lintcodes on Hello world!</title>
    <link>https://shiweiHou.github.io/lintcode/</link>
    <description>Recent content in Lintcodes on Hello world!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 07 Oct 2016 20:41:56 +0800</lastBuildDate>
    <atom:link href="https://shiweiHou.github.io/lintcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LintCode 和大于S的最小子数组</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-07-02/</link>
      <pubDate>Fri, 07 Oct 2016 20:41:56 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-07-02/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;p&gt;给定一个由 n 个整数组成的数组和一个正整数 s ，请找出该数组中满足其和 ≥ s 的最小长度子数组。如果无解，则返回 -1。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定数组 [2,3,1,2,4,3] 和 s = 7, 子数组 [4,3] 是该条件下的最小长度子数组。&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;LintCode上面挑战是O(n)时间复杂度，我想O（n*n）不知道可不可以过，于是就试了下，发现还是不行，73%的test通过。对于一个数组，然后要求O（n）时间复杂度的，一般都是通过两根指针，要么一个从头向尾和一个从尾向头，要么一个快指针，一个慢指针。我一开始用第一种方法，后来写出来发现还是O（n*n)的时间复杂度，于是改用快慢指针。因为s是正整数，所以我们可以不考虑负数的情况，利用快慢指针来求答案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int minimumSize(vector&amp;lt;int&amp;gt; &amp;amp;nums, int s) {
    // write your code here
    if (nums.empty()) return -1;

    int n = nums.size();
    int sum = 0;
    int minLength = n + 1;
    int fast = 0;
    int slow = 0;

    while (fast &amp;lt; n) {
        while (fast &amp;lt; n &amp;amp;&amp;amp; sum &amp;lt; s) { //首先找到从slow开始一直和大于s的fast为止
            sum += nums[fast];
            ++fast;
        }           //退出循环后，fast指向第一次和大于s的后面那个位置，即区间为[slow, fast)
        if (sum &amp;gt;= s &amp;amp;&amp;amp; minLength &amp;gt; fast - slow) minLength = fast - slow ;
        while (sum &amp;gt;= s) {
            if (sum &amp;gt;= s &amp;amp;&amp;amp; minLength &amp;gt; fast - slow ) minLength = fast - slow;
            sum -= nums[slow];  // 开始增加slow，减去前面的值，因为要求是连续的，所以直接减去即可
            ++slow;

        }
    }

    if (minLength == n + 1) return -1;
    return minLength;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 和为零的子矩阵</title>
      <link>https://shiweihou.github.io/lintcode/2016-10-07-01/</link>
      <pubDate>Fri, 07 Oct 2016 18:37:40 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/2016-10-07-01/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;p&gt;给定一个整数矩阵，请找出一个子矩阵，使得其数字之和等于0.输出答案时，请返回左上数字和右下数字的坐标。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定矩阵&lt;code&gt;[[1, 5, 7],[3, 7, 8],[4, -8, 9],]&lt;/code&gt;, 返回&lt;code&gt;[(1,1), (2,2)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始是想着暴搜看看能不能过，发现果然不能，只过了82%的test，还是可以的了~~~&lt;/p&gt;

&lt;p&gt;后来就想了个思路，既然是求和为0的矩阵，那么必然存在有两个矩阵一大一小，大小矩阵和是相等的，那么大矩阵和小矩阵的差别的那一块矩阵，就是和为0的矩阵。所以我们只要找到那两个矩阵和相等的一大一小的矩阵就可以了。其差值就是要求的答案。&lt;/p&gt;

&lt;p&gt;求矩阵和的时候是有个递推公式的，对于位于（i，j）处的矩阵和，其递推公式为 sum[i][j] = sum[i-1][j] + sum[i][j-1] + matrix[i][j],大家画一下图，很简单就出来了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; submatrixSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) {
    // Write your code here
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ret;
    if (matrix.empty()) return ret;
    ret.resize(2);
    ret[0].resize(2);
    ret[1].resize(2);

    int row = matrix.size();
    int col = matrix[0].size();

    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; sum(row+1, vector&amp;lt;int&amp;gt;(col+1, 0));

    for (int j = 0; j &amp;lt;= col; ++j) sum[0][j] = 0;
    for (int i = 0; i &amp;lt;= row; ++i) sum[i][0] = 0;

    for (int i = 0; i &amp;lt; row; ++i) {
        for (int j = 0; j &amp;lt; col; ++j) {
            sum[i+1][j+1] = matrix[i][j] + sum[i][j+1] + sum[i+1][j] - sum[i][j];
        }
    }

    for (int i = 0; i &amp;lt; row; ++i) {
        for (int k = i + 1; k &amp;lt;= row; ++k) {
            map&amp;lt;int, int&amp;gt; m;
            for (int j = 0; j &amp;lt;= col; ++j) {
                // 计算两个矩阵的差，如果差已经在map里面，说明这两个矩阵差相等的这两个矩阵之间就是那个矩阵和为0的子矩阵
                int diff = sum[k][j] - sum[i][j];
                if (m.find(diff) != m.end()) {
                    int l = m[diff];
                    ret[0][0] = i;
                    ret[0][1] = l;
                    ret[1][0] = k - 1;
                    ret[1][1] = j - 1;
                    return ret;
                } else m[diff] = j;
            }
        }
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 连续子数组求和</title>
      <link>https://shiweihou.github.io/lintcode/20161006-4/</link>
      <pubDate>Thu, 06 Oct 2016 21:16:05 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-4/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大。输出答案时，请分别返回第一个数字和最后一个数字的下标。（如果两个相同的答案，请返回其中任意一个）&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定&lt;code&gt;[-3, 1, 3, -3, 4]&lt;/code&gt;,返回&lt;code&gt;[1, 4]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;最大连续子数组问题，只要在求最大连续子数组和的过程中，记录最大值更改时的下标start和end就可以。利用动态规划来求最大子数组，因为要求是连续的，设dp[i]为第i个位置子数组的最大值。第i个位置的数要不要放进去，就要看如果第i个位置放进去，与dp[i-1]的和是否大于A[i],如果大于，就放进去，否则不放。时间复杂度O(n),代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; continuousSubarraySum(vector&amp;lt;int&amp;gt;&amp;amp; A) {
    // Write your code here
    vector&amp;lt;int&amp;gt; ret;
    if (A.empty()) return ret;
    int n = A.size();
    vector&amp;lt;int&amp;gt; cur(n,0);
    int maxSum = A[0];
    cur[0] = A[0];
    int curStart = 0;
    int start = 0;
    int end = 0;
    for (int i = 1; i &amp;lt; n; ++i) {
        if (cur[i-1] + A[i] &amp;gt; A[i]) { // 放进去，curs s e均不作更改
            cur[i] = cur[i-1] + A[i];
        } else {
            cur[i] = A[i];
            curStart = i;
        }
        if (cur[i] &amp;gt; maxSum) {
            maxSum = cur[i];
            start = curStart;
            end   = i;
        }
    }

    ret.push_back(start);
    ret.push_back(end);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 排序矩阵中的从小到大第k个数</title>
      <link>https://shiweihou.github.io/lintcode/20161006-3/</link>
      <pubDate>Thu, 06 Oct 2016 21:08:04 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-3/</guid>
      <description>&lt;p&gt;题目要求：&lt;/p&gt;

&lt;p&gt;在一个排序矩阵中找从小到大的第 k 个整数。排序矩阵的定义为：每一行递增，每一列也递增。&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;p&gt;给定 K = 4 和一个排序矩阵：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
 [1,5,7],
 [3,7,8],
 [4,8,9],
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回答案 5&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;一开始想错了，以为第i行的数字一定比第i+1行的数字要小，其实题目只要求每一行是递增，每一列数字是递增的，但并没有要求第i行的最后一个数字一定比第i+1行的倒数第二个数字小。我一开始是这样认为的，然后写好提交，发现居然过了73%的test，好神奇~~&lt;/p&gt;

&lt;p&gt;后来发现需要利用堆来做，利用STL里的堆模板，很容易写出来，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int k) {
    // write your code here
    int row = matrix.size();
    if (row == 0 || k == 0) return 0;
    int col = matrix[0].size();

    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;gt;&amp;gt; dui; //构建最小堆
    map&amp;lt;pair&amp;lt;int, int&amp;gt;, bool&amp;gt; visited;

    dui.push(make_pair(matrix[0][0], make_pair(0,0)));
    visited[make_pair(0,0)] = true;

    while (k--) {
        pair&amp;lt;int, pair&amp;lt;int, int&amp;gt; &amp;gt; cur = dui.top();
        dui.pop();

        if (k == 0) return cur.first;

        int x = cur.second.first + 1; // down
        int y = cur.second.second;
        if (x &amp;lt; row &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
        --x;
        ++y;//right-&amp;gt;

        if (y &amp;lt; col &amp;amp;&amp;amp; visited[make_pair(x,y)] == false) {
            dui.push(make_pair(matrix[x][y], make_pair(x,y)));
            visited[make_pair(x,y)] = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode 硬币排成线||</title>
      <link>https://shiweihou.github.io/lintcode/20161006-2/</link>
      <pubDate>Thu, 06 Oct 2016 20:46:56 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006-2/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有 n 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值高的人获胜。&lt;/p&gt;

&lt;p&gt;请判定 第一个玩家 是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定数组 A = [1,2,2],返回true&lt;/li&gt;
&lt;li&gt;给定数组 A = [1,2,4],返回false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;这道题看上去和前面那道硬币排线题很像，只不过第一个玩家赢的条件从是否能拿到最后一枚硬币变成第一个玩家拿到的硬币价值总和是否大于第二个玩家拿到的硬币价值总和。典型的博弈论题目，每个人都尽量在保证自己获得最大价值的情况下让对方获得最小价值。设第一个玩家为player1，第二个玩家为player2，v[i]为player1从硬币i到end所能拿到的最大价值。我们从后往前推：
对于硬币i和硬币i+1，player1有两种情况可以选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拿走硬币i，获得的价值为values[i]: 在player1拿走硬币i的情况下，那么player2有两种可以选择，一是拿走硬币i+1，那么此时player1拿走硬币i获得的价值就为 v1 = values[i] + v[i+2];二是拿走硬币i和硬币i+1,那么此时player1拿走硬币i获得的价值为 v2 = values[i] + v[i+3]。当然在博弈原则下，player2肯定是想让player1获得的价值最小，所以player1在拿走硬币i获得的最大价值为 choose1 = values[i] + min(v[i+2], v[i+3]).&lt;/li&gt;
&lt;li&gt;拿走硬币i和硬币i+1，获得的价值为values[i+1] + values[i]: 同上所述，player2同样有两种选择，一是拿走硬币i+2和硬币i+3，此时player1所能获得的最大价值为 v3 = values[i] + values[i+1] + v[i+4];二是拿走硬币i+2，此时player1所能获得的最大价值为 v4 = values[i] + values[i+1] + v[i+3]。同样基于博弈，player2肯定想让player1获得的最大价值最小，所以player1在拿走硬币i和硬币i+1的情况下获得的最大价值为 choose2 = values[i] + values[i+1] + min(v[i+3], v[i+4]).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，player1在两种选择下，要选择一个最大的价值 v[i] = max(choose1, choose2).
代码如下，注意越界情况，所以我定义v的数组时多定义了两个，并且设置为0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool firstWillWin(vector&amp;lt;int&amp;gt; &amp;amp;values) {
    // write your code here
    if (values.empty()) return false;

    int len = values.size();
    if (len &amp;lt;= 2) return true;
    vector&amp;lt;int&amp;gt; v(len+2,0);
    v[len-1] = values[len-1];
    v[len-2] = values[len-1] + values[len-2];
    int sum = values[len-1] + values[len-2];
    for (int i = len - 3; i &amp;gt;= 0; --i) {
        sum += values[i];
        int choose1, choose2;
        choose1 = values[i] + min(v[i+2], v[i+3]);
        choose2 = values[i] + values[i+1] + min(v[i+4],v[i+3]);
        v[i] = max(choose1, choose2);
    }

    return sum-v[0] &amp;lt; v[0];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LintCode-硬币排成线</title>
      <link>https://shiweihou.github.io/lintcode/20161006/</link>
      <pubDate>Thu, 06 Oct 2016 20:29:52 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/20161006/</guid>
      <description>&lt;p&gt;题目描述：&lt;/p&gt;

&lt;p&gt;有N个硬币排成一条线，两个参赛者轮流从右边依次拿走1个或2个硬币，直到没有硬币为止。拿到最后一个硬币的玩家获胜。请判定第一个玩家是输还是赢？&lt;/p&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;n = 1, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 2, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 3, 返回 false&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 4, 返回 true&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;n = 5, 返回 true
思路：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这道题是有关博弈论的初级题目。题目很简单，就是判断第一个人最后能否拿到最后一枚硬币。我们不能依赖于第二个玩家怎么拿，我们需要的答案是无论第二个玩家怎么拿，第一个玩家在现有的拿法下（每次拿一个或者两个）可以拿到最后一个硬币或者拿不到。很明显，当只剩下三个硬币的时候，无论第一个玩家怎么拿，最后一个硬币都有可能不是他的，也就是说第一个玩家没有机会获胜。因此，我们只需要判断当还剩下三个的时候，最后一个拿硬币的人是否是第一个人就可以了，很明显可以用递归来做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n) {
        // write your code here
        if (n &amp;lt;= 0 || n == 3) return false;
        else if (n &amp;lt;= 4) return true;
        return firstWillWin(n-3);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理，亦可以利用动态规划来做，因为第i个硬币是否为第一个人拿和第i-3个硬币是否是第一个人拿真假值相同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        vector&amp;lt;bool&amp;gt; dp(n + 1, false);
        dp[0] = false;
        dp[1] = true;
        dp[2] = true;
        dp[3] = false;
        for (int i = 4; i &amp;lt;= n; ++i) {
            dp[i] = dp[i-3];
        }
        return dp[n];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种更为简洁的数学方法，因为我们发现如果硬币的个数不是3的倍数，那么第一个人就可以拿到最后一个硬币：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool firstWillWin(int n){
        if (n &amp;lt;= 0) return false;
        if (n % 3 == 1 || n % 3 == 2) return true;
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>first</title>
      <link>https://shiweihou.github.io/lintcode/first/</link>
      <pubDate>Mon, 03 Oct 2016 20:08:35 +0800</pubDate>
      
      <guid>https://shiweihou.github.io/lintcode/first/</guid>
      <description>&lt;p&gt;lintcode&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>